{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentation","text":""},{"location":"#overview","title":"Overview","text":"<p>Iwa is designed to be the foundation for secure python-based crypto agents and applications.</p>"},{"location":"#key-concepts","title":"Key Concepts","text":""},{"location":"#key-management","title":"Key Management","text":"<p>Security is paramount. <code>KeyStorage</code> is the \"vault\". It uses a user-provided password to encrypt private keys at rest. When needed, keys are decrypted only transiently for signing and then cleared. Developer Rule: Never use <code>_get_private_key</code>. Use <code>sign_transaction</code> or <code>sign_message</code>.</p>"},{"location":"#plugins","title":"Plugins","text":"<p>To add a new protocol: 1. Create a directory in <code>src/iwa/plugins/&lt;protocol_name&gt;</code>. 2. Implement a <code>Plugin</code> class inheriting from <code>iwa.core.plugins.Plugin</code> in <code>plugin.py</code>. 3. Define CLI commands in your plugin class. 4. Export the plugin class in <code>__init__.py</code>. The <code>PluginLoader</code> will automatically discover it.</p>"},{"location":"#chains","title":"Chains","text":"<p>Support for new chains can be added in <code>src/iwa/core/chain.py</code> by inheriting from <code>SupportedChain</code>.</p>"},{"location":"#api-reference","title":"API Reference","text":"<p>(Run <code>pydoc</code> or view source for standard docstrings)</p>"},{"location":"cli/","title":"CLI Reference","text":"<p>The Iwa CLI is the primary way to interact with the framework. It is built using <code>typer</code>.</p>"},{"location":"cli/#main-command","title":"Main Command","text":""},{"location":"cli/#iwa.core.cli","title":"<code>iwa.core.cli</code>","text":"<p>CLI</p>"},{"location":"cli/#iwa.core.cli.iwa_cli","title":"<code>iwa_cli = typer.Typer(help='iwa command line interface')</code>  <code>module-attribute</code>","text":""},{"location":"core/","title":"Core Modules This section documents the core components of the Iwa framework.","text":""},{"location":"core/#keystorage","title":"KeyStorage","text":""},{"location":"core/#iwa.core.keys","title":"<code>iwa.core.keys</code>","text":"<p>Wallet management</p>"},{"location":"core/#iwa.core.keys.KeyStorage","title":"<code>KeyStorage</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>KeyStorage</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>class KeyStorage(BaseModel):\n    \"\"\"KeyStorage\"\"\"\n\n    accounts: Dict[EthereumAddress, Union[EncryptedAccount, StoredSafeAccount]] = {}\n    _path: Path = PrivateAttr()  # not stored nor validated\n    _password: str = PrivateAttr()\n\n    def __init__(self, path: Path = Path(WALLET_PATH), password: Optional[str] = None):\n        \"\"\"Initialize key storage.\"\"\"\n        super().__init__()\n        self._path = path\n        if password is None:\n            password = settings.wallet_password.get_secret_value()\n        self._password = password\n\n        if os.path.exists(path):\n            try:\n                with open(path, \"r\") as f:\n                    data = json.load(f)\n                    self.accounts = {\n                        k: EncryptedAccount(**v) if \"signers\" not in v else StoredSafeAccount(**v)\n                        for k, v in data.get(\"accounts\", {}).items()\n                    }\n            except json.JSONDecodeError:\n                logger.error(f\"Failed to load wallet from {path}: File is corrupted.\")\n                self.accounts = {}\n        else:\n            self.accounts = {}\n\n        # Ensure 'master' account exists\n        if not self.get_address_by_tag(\"master\"):\n            logger.info(\"Master account not found. Creating new 'master' account...\")\n            try:\n                self.create_account(\"master\")\n            except Exception as e:\n                logger.error(f\"Failed to create master account: {e}\")\n\n    @property\n    def master_account(self) -&gt; EncryptedAccount:\n        \"\"\"Get the master account\"\"\"\n        master_account = self.get_account(\"master\")\n\n        if not master_account:\n            return list(self.accounts.values())[0]\n\n        return master_account\n\n    def save(self):\n        \"\"\"Save\"\"\"\n        # Ensure directory exists\n        self._path.parent.mkdir(parents=True, exist_ok=True)\n\n        with open(self._path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(self.model_dump(), f, indent=4)\n\n        # Enforce read/write only for the owner\n        os.chmod(self._path, 0o600)\n\n    def create_account(self, tag: str) -&gt; EncryptedAccount:\n        \"\"\"Create account\"\"\"\n        tags = [acct.tag for acct in self.accounts.values()]\n        if not tags:\n            tag = \"master\"  # First account is always master\n        if tag in tags:\n            raise ValueError(f\"Tag '{tag}' already exists in wallet.\")\n\n        acct = Account.create()\n\n        encrypted = EncryptedAccount.encrypt_private_key(acct.key.hex(), self._password, tag)\n        self.accounts[acct.address] = encrypted\n        self.save()\n        return encrypted\n\n    def remove_account(self, address_or_tag: str):\n        \"\"\"Remove account\"\"\"\n        account = self.find_stored_account(address_or_tag)\n        if not account:\n            return\n\n        del self.accounts[account.address]\n        self.save()\n\n    def _get_private_key(self, address: str) -&gt; Optional[str]:\n        \"\"\"Get private key (Internal)\"\"\"\n        account = self.accounts.get(EthereumAddress(address))\n        if not account:\n            return None\n        if isinstance(account, StoredSafeAccount):\n            raise ValueError(f\"Cannot get private key for Safe account {address}\")\n\n        return account.decrypt_private_key(self._password)\n\n    # NOTE: get_private_key_unsafe() was removed for security reasons.\n    # Use sign_transaction(), sign_message(), or get_signer() instead.\n\n    def sign_message(self, message: bytes, signer_address_or_tag: str) -&gt; bytes:\n        \"\"\"Sign a message internally without exposing the private key.\n\n        Args:\n            message: The message bytes to sign\n            signer_address_or_tag: The address or tag of the signer\n\n        Returns:\n            The signature bytes\n\n        \"\"\"\n        signer_account = self.find_stored_account(signer_address_or_tag)\n        if not signer_account:\n            raise ValueError(f\"Signer account '{signer_address_or_tag}' not found.\")\n\n        if isinstance(signer_account, StoredSafeAccount):\n            raise ValueError(\"Direct message signing not supported for Safe accounts.\")\n\n        private_key = self._get_private_key(signer_account.address)\n        if not private_key:\n            raise ValueError(f\"Private key not found for {signer_address_or_tag}\")\n\n        from eth_account.messages import encode_defunct\n\n        message_hash = encode_defunct(primitive=message)\n        signed = Account.sign_message(message_hash, private_key=private_key)\n        return signed.signature\n\n    def sign_typed_data(self, typed_data: dict, signer_address_or_tag: str) -&gt; bytes:\n        \"\"\"Sign EIP-712 typed data internally without exposing the private key.\n\n        Args:\n            typed_data: EIP-712 typed data dictionary\n            signer_address_or_tag: The address or tag of the signer\n\n        Returns:\n            The signature bytes\n\n        \"\"\"\n        signer_account = self.find_stored_account(signer_address_or_tag)\n        if not signer_account:\n            raise ValueError(f\"Signer account '{signer_address_or_tag}' not found.\")\n\n        if isinstance(signer_account, StoredSafeAccount):\n            raise ValueError(\"Direct message signing not supported for Safe accounts.\")\n\n        private_key = self._get_private_key(signer_account.address)\n        if not private_key:\n            raise ValueError(f\"Private key not found for {signer_address_or_tag}\")\n\n        signed = Account.sign_typed_data(private_key=private_key, full_message=typed_data)\n        return signed.signature\n\n    def get_signer(self, address_or_tag: str) -&gt; Optional[LocalAccount]:\n        \"\"\"Get a LocalAccount signer for the address or tag.\n\n        Note: This method returns a LocalAccount which encapsulates the private key.\n        It's used for APIs that require a signer object (e.g., CowSwap).\n        Prefer sign_transaction() or sign_message() when possible.\n        \"\"\"\n        account = self.find_stored_account(address_or_tag)\n        if not account:\n            return None\n\n        # Safe accounts cannot be signers directly in this context (usually)\n        if isinstance(account, StoredSafeAccount):\n            return None\n\n        private_key = self._get_private_key(account.address)\n        if not private_key:\n            return None\n\n        return Account.from_key(private_key)\n\n    def sign_transaction(self, transaction: dict, signer_address_or_tag: str):\n        \"\"\"Sign a transaction\"\"\"\n        signer_account = self.find_stored_account(signer_address_or_tag)\n        if not signer_account:\n            raise ValueError(f\"Signer account '{signer_address_or_tag}' not found.\")\n\n        if isinstance(signer_account, StoredSafeAccount):\n            raise ValueError(\"Direct transaction signing not supported for Safe accounts.\")\n\n        private_key = self._get_private_key(signer_account.address)\n        if not private_key:\n            raise ValueError(f\"Private key not found for {signer_address_or_tag}\")\n\n        signed = Account.sign_transaction(transaction, private_key)\n        return signed\n\n    # ... (create_safe omitted for brevity, but I should log there too if needed)\n\n    def find_stored_account(\n        self, address_or_tag: str\n    ) -&gt; Optional[Union[EncryptedAccount, StoredSafeAccount]]:\n        \"\"\"Find a stored account by address or tag.\"\"\"\n        # Try tag first\n        for acc in self.accounts.values():\n            if acc.tag == address_or_tag:\n                return acc\n\n        # Then try address\n        try:\n            addr = EthereumAddress(address_or_tag)\n            return self.accounts.get(addr)\n        except ValueError:\n            return None\n\n    def get_account(self, address_or_tag: str) -&gt; Optional[Union[StoredAccount, StoredSafeAccount]]:\n        \"\"\"Get basic account info without exposing any possibility of private key access.\"\"\"\n        stored = self.find_stored_account(address_or_tag)\n        if not stored:\n            return None\n        if isinstance(stored, StoredSafeAccount):\n            return stored\n        return StoredAccount(address=stored.address, tag=stored.tag)\n\n    def get_account_info(\n        self, address_or_tag: str\n    ) -&gt; Optional[Union[StoredAccount, StoredSafeAccount]]:\n        \"\"\"Alias for get_account for clarity when specifically requesting metadata.\"\"\"\n        return self.get_account(address_or_tag)\n\n    def get_tag_by_address(self, address: EthereumAddress) -&gt; Optional[str]:\n        \"\"\"Get tag by address\"\"\"\n        account = self.accounts.get(EthereumAddress(address))\n        if account:\n            return account.tag\n        return None\n\n    def get_address_by_tag(self, tag: str) -&gt; Optional[EthereumAddress]:\n        \"\"\"Get address by tag\"\"\"\n        for account in self.accounts.values():\n            if account.tag == tag:\n                return EthereumAddress(account.address)\n        return None\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.master_account","title":"<code>master_account</code>  <code>property</code>","text":"<p>Get the master account</p>"},{"location":"core/#iwa.core.keys.KeyStorage.__init__","title":"<code>__init__(path=Path(WALLET_PATH), password=None)</code>","text":"<p>Initialize key storage.</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def __init__(self, path: Path = Path(WALLET_PATH), password: Optional[str] = None):\n    \"\"\"Initialize key storage.\"\"\"\n    super().__init__()\n    self._path = path\n    if password is None:\n        password = settings.wallet_password.get_secret_value()\n    self._password = password\n\n    if os.path.exists(path):\n        try:\n            with open(path, \"r\") as f:\n                data = json.load(f)\n                self.accounts = {\n                    k: EncryptedAccount(**v) if \"signers\" not in v else StoredSafeAccount(**v)\n                    for k, v in data.get(\"accounts\", {}).items()\n                }\n        except json.JSONDecodeError:\n            logger.error(f\"Failed to load wallet from {path}: File is corrupted.\")\n            self.accounts = {}\n    else:\n        self.accounts = {}\n\n    # Ensure 'master' account exists\n    if not self.get_address_by_tag(\"master\"):\n        logger.info(\"Master account not found. Creating new 'master' account...\")\n        try:\n            self.create_account(\"master\")\n        except Exception as e:\n            logger.error(f\"Failed to create master account: {e}\")\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.create_account","title":"<code>create_account(tag)</code>","text":"<p>Create account</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def create_account(self, tag: str) -&gt; EncryptedAccount:\n    \"\"\"Create account\"\"\"\n    tags = [acct.tag for acct in self.accounts.values()]\n    if not tags:\n        tag = \"master\"  # First account is always master\n    if tag in tags:\n        raise ValueError(f\"Tag '{tag}' already exists in wallet.\")\n\n    acct = Account.create()\n\n    encrypted = EncryptedAccount.encrypt_private_key(acct.key.hex(), self._password, tag)\n    self.accounts[acct.address] = encrypted\n    self.save()\n    return encrypted\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.find_stored_account","title":"<code>find_stored_account(address_or_tag)</code>","text":"<p>Find a stored account by address or tag.</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def find_stored_account(\n    self, address_or_tag: str\n) -&gt; Optional[Union[EncryptedAccount, StoredSafeAccount]]:\n    \"\"\"Find a stored account by address or tag.\"\"\"\n    # Try tag first\n    for acc in self.accounts.values():\n        if acc.tag == address_or_tag:\n            return acc\n\n    # Then try address\n    try:\n        addr = EthereumAddress(address_or_tag)\n        return self.accounts.get(addr)\n    except ValueError:\n        return None\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.get_account","title":"<code>get_account(address_or_tag)</code>","text":"<p>Get basic account info without exposing any possibility of private key access.</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def get_account(self, address_or_tag: str) -&gt; Optional[Union[StoredAccount, StoredSafeAccount]]:\n    \"\"\"Get basic account info without exposing any possibility of private key access.\"\"\"\n    stored = self.find_stored_account(address_or_tag)\n    if not stored:\n        return None\n    if isinstance(stored, StoredSafeAccount):\n        return stored\n    return StoredAccount(address=stored.address, tag=stored.tag)\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.get_account_info","title":"<code>get_account_info(address_or_tag)</code>","text":"<p>Alias for get_account for clarity when specifically requesting metadata.</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def get_account_info(\n    self, address_or_tag: str\n) -&gt; Optional[Union[StoredAccount, StoredSafeAccount]]:\n    \"\"\"Alias for get_account for clarity when specifically requesting metadata.\"\"\"\n    return self.get_account(address_or_tag)\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.get_address_by_tag","title":"<code>get_address_by_tag(tag)</code>","text":"<p>Get address by tag</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def get_address_by_tag(self, tag: str) -&gt; Optional[EthereumAddress]:\n    \"\"\"Get address by tag\"\"\"\n    for account in self.accounts.values():\n        if account.tag == tag:\n            return EthereumAddress(account.address)\n    return None\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.get_signer","title":"<code>get_signer(address_or_tag)</code>","text":"<p>Get a LocalAccount signer for the address or tag.</p> <p>Note: This method returns a LocalAccount which encapsulates the private key. It's used for APIs that require a signer object (e.g., CowSwap). Prefer sign_transaction() or sign_message() when possible.</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def get_signer(self, address_or_tag: str) -&gt; Optional[LocalAccount]:\n    \"\"\"Get a LocalAccount signer for the address or tag.\n\n    Note: This method returns a LocalAccount which encapsulates the private key.\n    It's used for APIs that require a signer object (e.g., CowSwap).\n    Prefer sign_transaction() or sign_message() when possible.\n    \"\"\"\n    account = self.find_stored_account(address_or_tag)\n    if not account:\n        return None\n\n    # Safe accounts cannot be signers directly in this context (usually)\n    if isinstance(account, StoredSafeAccount):\n        return None\n\n    private_key = self._get_private_key(account.address)\n    if not private_key:\n        return None\n\n    return Account.from_key(private_key)\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.get_tag_by_address","title":"<code>get_tag_by_address(address)</code>","text":"<p>Get tag by address</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def get_tag_by_address(self, address: EthereumAddress) -&gt; Optional[str]:\n    \"\"\"Get tag by address\"\"\"\n    account = self.accounts.get(EthereumAddress(address))\n    if account:\n        return account.tag\n    return None\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.remove_account","title":"<code>remove_account(address_or_tag)</code>","text":"<p>Remove account</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def remove_account(self, address_or_tag: str):\n    \"\"\"Remove account\"\"\"\n    account = self.find_stored_account(address_or_tag)\n    if not account:\n        return\n\n    del self.accounts[account.address]\n    self.save()\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.save","title":"<code>save()</code>","text":"<p>Save</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def save(self):\n    \"\"\"Save\"\"\"\n    # Ensure directory exists\n    self._path.parent.mkdir(parents=True, exist_ok=True)\n\n    with open(self._path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(self.model_dump(), f, indent=4)\n\n    # Enforce read/write only for the owner\n    os.chmod(self._path, 0o600)\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.sign_message","title":"<code>sign_message(message, signer_address_or_tag)</code>","text":"<p>Sign a message internally without exposing the private key.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes</code> <p>The message bytes to sign</p> required <code>signer_address_or_tag</code> <code>str</code> <p>The address or tag of the signer</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The signature bytes</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def sign_message(self, message: bytes, signer_address_or_tag: str) -&gt; bytes:\n    \"\"\"Sign a message internally without exposing the private key.\n\n    Args:\n        message: The message bytes to sign\n        signer_address_or_tag: The address or tag of the signer\n\n    Returns:\n        The signature bytes\n\n    \"\"\"\n    signer_account = self.find_stored_account(signer_address_or_tag)\n    if not signer_account:\n        raise ValueError(f\"Signer account '{signer_address_or_tag}' not found.\")\n\n    if isinstance(signer_account, StoredSafeAccount):\n        raise ValueError(\"Direct message signing not supported for Safe accounts.\")\n\n    private_key = self._get_private_key(signer_account.address)\n    if not private_key:\n        raise ValueError(f\"Private key not found for {signer_address_or_tag}\")\n\n    from eth_account.messages import encode_defunct\n\n    message_hash = encode_defunct(primitive=message)\n    signed = Account.sign_message(message_hash, private_key=private_key)\n    return signed.signature\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.sign_transaction","title":"<code>sign_transaction(transaction, signer_address_or_tag)</code>","text":"<p>Sign a transaction</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def sign_transaction(self, transaction: dict, signer_address_or_tag: str):\n    \"\"\"Sign a transaction\"\"\"\n    signer_account = self.find_stored_account(signer_address_or_tag)\n    if not signer_account:\n        raise ValueError(f\"Signer account '{signer_address_or_tag}' not found.\")\n\n    if isinstance(signer_account, StoredSafeAccount):\n        raise ValueError(\"Direct transaction signing not supported for Safe accounts.\")\n\n    private_key = self._get_private_key(signer_account.address)\n    if not private_key:\n        raise ValueError(f\"Private key not found for {signer_address_or_tag}\")\n\n    signed = Account.sign_transaction(transaction, private_key)\n    return signed\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.sign_typed_data","title":"<code>sign_typed_data(typed_data, signer_address_or_tag)</code>","text":"<p>Sign EIP-712 typed data internally without exposing the private key.</p> <p>Parameters:</p> Name Type Description Default <code>typed_data</code> <code>dict</code> <p>EIP-712 typed data dictionary</p> required <code>signer_address_or_tag</code> <code>str</code> <p>The address or tag of the signer</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The signature bytes</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def sign_typed_data(self, typed_data: dict, signer_address_or_tag: str) -&gt; bytes:\n    \"\"\"Sign EIP-712 typed data internally without exposing the private key.\n\n    Args:\n        typed_data: EIP-712 typed data dictionary\n        signer_address_or_tag: The address or tag of the signer\n\n    Returns:\n        The signature bytes\n\n    \"\"\"\n    signer_account = self.find_stored_account(signer_address_or_tag)\n    if not signer_account:\n        raise ValueError(f\"Signer account '{signer_address_or_tag}' not found.\")\n\n    if isinstance(signer_account, StoredSafeAccount):\n        raise ValueError(\"Direct message signing not supported for Safe accounts.\")\n\n    private_key = self._get_private_key(signer_account.address)\n    if not private_key:\n        raise ValueError(f\"Private key not found for {signer_address_or_tag}\")\n\n    signed = Account.sign_typed_data(private_key=private_key, full_message=typed_data)\n    return signed.signature\n</code></pre>"},{"location":"core/#iwa.core.keys.EncryptedAccount","title":"<code>EncryptedAccount</code>","text":"<p>               Bases: <code>StoredAccount</code></p> <p>EncryptedAccount</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>class EncryptedAccount(StoredAccount):\n    \"\"\"EncryptedAccount\"\"\"\n\n    salt: str\n    nonce: str\n    ciphertext: str\n\n    @staticmethod\n    def derive_key(password: str, salt: bytes) -&gt; bytes:\n        \"\"\"Derive key\"\"\"\n        kdf = Scrypt(\n            salt=salt,\n            length=32,\n            n=2**14,\n            r=8,\n            p=1,\n        )\n        return kdf.derive(password.encode())\n\n    def decrypt_private_key(self, password: Optional[str] = None) -&gt; str:\n        \"\"\"decrypt_private_key\"\"\"\n        if not password and not settings.wallet_password:\n            raise ValueError(\"Password must be provided or set in secrets.env (WALLET_PASSWORD)\")\n        if not password:\n            password = settings.wallet_password.get_secret_value()\n        salt_bytes = base64.b64decode(self.salt)\n        nonce_bytes = base64.b64decode(self.nonce)\n        ciphertext_bytes = base64.b64decode(self.ciphertext)\n        key = EncryptedAccount.derive_key(password, salt_bytes)\n        aesgcm = AESGCM(key)\n        return aesgcm.decrypt(nonce_bytes, ciphertext_bytes, None).decode()\n\n    @staticmethod\n    def encrypt_private_key(\n        private_key: str, password: str, tag: Optional[str] = None\n    ) -&gt; \"EncryptedAccount\":\n        \"\"\"Encrypt private key\"\"\"\n        salt = os.urandom(16)\n        key = EncryptedAccount.derive_key(password, salt)\n        aesgcm = AESGCM(key)\n        nonce = os.urandom(12)\n        ciphertext = aesgcm.encrypt(nonce, private_key.encode(), None)\n\n        acct = Account.from_key(private_key)\n        return EncryptedAccount(\n            address=acct.address,\n            salt=base64.b64encode(salt).decode(),\n            nonce=base64.b64encode(nonce).decode(),\n            ciphertext=base64.b64encode(ciphertext).decode(),\n            tag=tag,\n        )\n</code></pre>"},{"location":"core/#iwa.core.keys.EncryptedAccount.decrypt_private_key","title":"<code>decrypt_private_key(password=None)</code>","text":"<p>decrypt_private_key</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def decrypt_private_key(self, password: Optional[str] = None) -&gt; str:\n    \"\"\"decrypt_private_key\"\"\"\n    if not password and not settings.wallet_password:\n        raise ValueError(\"Password must be provided or set in secrets.env (WALLET_PASSWORD)\")\n    if not password:\n        password = settings.wallet_password.get_secret_value()\n    salt_bytes = base64.b64decode(self.salt)\n    nonce_bytes = base64.b64decode(self.nonce)\n    ciphertext_bytes = base64.b64decode(self.ciphertext)\n    key = EncryptedAccount.derive_key(password, salt_bytes)\n    aesgcm = AESGCM(key)\n    return aesgcm.decrypt(nonce_bytes, ciphertext_bytes, None).decode()\n</code></pre>"},{"location":"core/#iwa.core.keys.EncryptedAccount.derive_key","title":"<code>derive_key(password, salt)</code>  <code>staticmethod</code>","text":"<p>Derive key</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>@staticmethod\ndef derive_key(password: str, salt: bytes) -&gt; bytes:\n    \"\"\"Derive key\"\"\"\n    kdf = Scrypt(\n        salt=salt,\n        length=32,\n        n=2**14,\n        r=8,\n        p=1,\n    )\n    return kdf.derive(password.encode())\n</code></pre>"},{"location":"core/#iwa.core.keys.EncryptedAccount.encrypt_private_key","title":"<code>encrypt_private_key(private_key, password, tag=None)</code>  <code>staticmethod</code>","text":"<p>Encrypt private key</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>@staticmethod\ndef encrypt_private_key(\n    private_key: str, password: str, tag: Optional[str] = None\n) -&gt; \"EncryptedAccount\":\n    \"\"\"Encrypt private key\"\"\"\n    salt = os.urandom(16)\n    key = EncryptedAccount.derive_key(password, salt)\n    aesgcm = AESGCM(key)\n    nonce = os.urandom(12)\n    ciphertext = aesgcm.encrypt(nonce, private_key.encode(), None)\n\n    acct = Account.from_key(private_key)\n    return EncryptedAccount(\n        address=acct.address,\n        salt=base64.b64encode(salt).decode(),\n        nonce=base64.b64encode(nonce).decode(),\n        ciphertext=base64.b64encode(ciphertext).decode(),\n        tag=tag,\n    )\n</code></pre>"},{"location":"core/#iwa.core.keys.StoredSafeAccount","title":"<code>StoredSafeAccount</code>","text":"<p>               Bases: <code>StoredAccount</code></p> <p>StoredSafeAccount representing a Gnosis Safe.</p> Source code in <code>src/iwa/core/models.py</code> <pre><code>class StoredSafeAccount(StoredAccount):\n    \"\"\"StoredSafeAccount representing a Gnosis Safe.\"\"\"\n\n    signers: List[EthereumAddress] = Field(description=\"List of owner addresses\")\n    threshold: int = Field(description=\"Required signatures threshold\")\n    chains: List[str] = Field(description=\"List of supported chains\")\n</code></pre>"},{"location":"core/#wallet","title":"Wallet","text":""},{"location":"core/#iwa.core.wallet","title":"<code>iwa.core.wallet</code>","text":"<p>Wallet module.</p>"},{"location":"core/#iwa.core.wallet.Wallet","title":"<code>Wallet</code>","text":"<p>Wallet management coordinator.</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>class Wallet:\n    \"\"\"Wallet management coordinator.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize wallet.\"\"\"\n        self.key_storage = KeyStorage()\n        self.account_service = AccountService(self.key_storage)\n        self.balance_service = BalanceService(self.key_storage, self.account_service)\n        self.safe_service = SafeService(self.key_storage, self.account_service)\n        # self.transaction_manager = TransactionManager(self.key_storage, self.account_service)\n        self.transaction_service = TransactionService(self.key_storage, self.account_service)\n\n        self.transfer_service = TransferService(\n            self.key_storage,\n            self.account_service,\n            self.balance_service,\n            self.safe_service,\n            self.transaction_service,\n        )\n        self.plugin_service = PluginService()\n\n        init_db()\n\n    @property\n    def master_account(self) -&gt; Optional[StoredSafeAccount]:\n        \"\"\"Get master account\"\"\"\n        return self.account_service.master_account\n\n    def get_token_address(\n        self, token_address_or_name: str, chain: SupportedChain\n    ) -&gt; Optional[EthereumAddress]:\n        \"\"\"Get token address from address or name\"\"\"\n        return self.account_service.get_token_address(token_address_or_name, chain)\n\n    def get_accounts_balances(\n        self, chain_name: str, token_names: Optional[list[str]] = None\n    ) -&gt; Tuple[dict, Optional[dict]]:\n        \"\"\"Get accounts data and balances.\"\"\"\n        accounts_data = self.account_service.get_account_data()\n        token_names = token_names or []\n\n        if not token_names:\n            return accounts_data, None\n\n        token_balances = {addr: {} for addr in accounts_data.keys()}\n\n        def fetch_balance(addr, t_name):\n            try:\n                if t_name == \"native\":\n                    return (\n                        addr,\n                        t_name,\n                        self.balance_service.get_native_balance_eth(addr, chain_name),\n                    )\n                else:\n                    return (\n                        addr,\n                        t_name,\n                        self.balance_service.get_erc20_balance_eth(addr, t_name, chain_name),\n                    )\n            except Exception as e:\n                logger.error(f\"Error fetching {t_name} balance for {addr}: {e}\")\n                return addr, t_name, 0.0\n\n        # Use ThreadPoolExecutor for parallel balance fetching\n        with ThreadPoolExecutor(max_workers=20) as executor:\n            tasks = []\n            for addr in accounts_data.keys():\n                for t_name in token_names:\n                    tasks.append(executor.submit(fetch_balance, addr, t_name))\n\n            for future in tasks:\n                addr, t_name, bal = future.result()\n                token_balances[addr][t_name] = bal\n\n        return accounts_data, token_balances\n\n    def send_native_transfer(\n        self,\n        from_address: str,\n        to_address: str,\n        value_wei: Wei,\n        chain_name: str = \"gnosis\",\n    ) -&gt; Tuple[bool, Optional[str]]:\n        \"\"\"Send a native currency transfer (e.g., ETH, xDAI).\n\n        Args:\n            from_address: Sender's address or tag.\n            to_address: Recipient's address or tag.\n            value_wei: Amount to send in Wei.\n            chain_name: Target blockchain name (default: \"gnosis\").\n\n        Returns:\n            Tuple containing:\n                - bool: True if transaction was successfully sent (status=1).\n                - Optional[str]: Transaction hash if successful, None otherwise.\n\n        \"\"\"\n        tx_hash = self.transfer_service.send(\n            from_address_or_tag=from_address,\n            to_address_or_tag=to_address,\n            amount_wei=value_wei,\n            token_address_or_name=\"native\",\n            chain_name=chain_name,\n        )\n        return bool(tx_hash), tx_hash\n\n    def sign_and_send_transaction(\n        self, transaction: dict, signer_address_or_tag: str, chain_name: str = \"gnosis\"\n    ) -&gt; Tuple[bool, dict]:\n        \"\"\"Sign and send a raw transaction dictionary.\n\n        Args:\n            transaction: Dictionary containing transaction parameters.\n            signer_address_or_tag: Address or tag of the signing account.\n            chain_name: Target blockchain name (default: \"gnosis\").\n\n        Returns:\n            Tuple containing:\n                - bool: True if successful.\n                - dict: Transaction receipt or error details.\n\n        \"\"\"\n        return self.transaction_service.sign_and_send(\n            transaction, signer_address_or_tag, chain_name\n        )\n\n    def send_erc20_transfer(\n        self,\n        from_address: str,\n        to_address: str,\n        amount_wei: Wei,\n        token_address: str,\n        chain_name: str = \"gnosis\",\n    ) -&gt; Tuple[bool, Optional[str]]:\n        \"\"\"Send an ERC20 token transfer.\n\n        Args:\n            from_address: Sender's address or tag.\n            to_address: Recipient's address or tag.\n            amount_wei: Amount to send in Wei.\n            token_address: Token address or name (e.g., \"OLAS\").\n            chain_name: Target blockchain name (default: \"gnosis\").\n\n        Returns:\n            Tuple containing:\n                - bool: True if transaction was successfully sent (status=1).\n                - Optional[str]: Transaction hash if successful, None otherwise.\n\n        \"\"\"\n        tx_hash = self.transfer_service.send(\n            from_address_or_tag=from_address,\n            to_address_or_tag=to_address,\n            amount_wei=amount_wei,\n            token_address_or_name=token_address,\n            chain_name=chain_name,\n        )\n        return bool(tx_hash), tx_hash\n\n    def send(\n        self,\n        from_address_or_tag: str,\n        to_address_or_tag: str,\n        amount_wei: Wei,\n        token_address_or_name: str = \"native\",\n        chain_name: str = \"gnosis\",\n    ) -&gt; Optional[str]:\n        \"\"\"Send native currency or ERC20 tokens.\n\n        Unified interface for transferring assets.\n\n        Args:\n            from_address_or_tag: Sender's address or tag.\n            to_address_or_tag: Recipient's address or tag.\n            amount_wei: Amount to send in Wei.\n            token_address_or_name: Token address, name, or \"native\".\n            chain_name: Target blockchain name.\n\n        Returns:\n            Optional[str]: Transaction hash if successful, None otherwise.\n\n        \"\"\"\n        return self.transfer_service.send(\n            from_address_or_tag,\n            to_address_or_tag,\n            amount_wei,\n            token_address_or_name,\n            chain_name,\n        )\n\n    def multi_send(\n        self,\n        from_address_or_tag: str,\n        transactions: list,\n        chain_name: str = \"gnosis\",\n    ):\n        \"\"\"Send multiple transactions in a single multisend transaction\"\"\"\n        return self.transfer_service.multi_send(from_address_or_tag, transactions, chain_name)\n\n    def get_native_balance_eth(\n        self, account_address: str, chain_name: str = \"gnosis\"\n    ) -&gt; Optional[float]:\n        \"\"\"Get native currency balance\"\"\"\n        return self.balance_service.get_native_balance_eth(account_address, chain_name)\n\n    def get_native_balance_wei(\n        self, account_address: str, chain_name: str = \"gnosis\"\n    ) -&gt; Optional[Wei]:\n        \"\"\"Get native currency balance\"\"\"\n        return self.balance_service.get_native_balance_wei(account_address, chain_name)\n\n    def get_erc20_balance_eth(\n        self, account_address_or_tag: str, token_address_or_name: str, chain_name: str = \"gnosis\"\n    ) -&gt; Optional[float]:\n        \"\"\"Get ERC20 token balance\"\"\"\n        return self.balance_service.get_erc20_balance_eth(\n            account_address_or_tag, token_address_or_name, chain_name\n        )\n\n    def get_erc20_balance_wei(\n        self, account_address_or_tag: str, token_address_or_name: str, chain_name: str = \"gnosis\"\n    ) -&gt; Optional[Wei]:\n        \"\"\"Get ERC20 token balance\"\"\"\n        return self.balance_service.get_erc20_balance_wei(\n            account_address_or_tag, token_address_or_name, chain_name\n        )\n\n    def get_erc20_allowance(\n        self,\n        owner_address_or_tag: str,\n        spender_address: str,\n        token_address_or_name: str,\n        chain_name: str = \"gnosis\",\n    ) -&gt; Optional[float]:\n        \"\"\"Get ERC20 token allowance.\n\n        Args:\n            owner_address_or_tag: Token owner's address or tag.\n            spender_address: Address authorized to spend tokens.\n            token_address_or_name: Token address or name.\n            chain_name: Target blockchain name.\n\n        Returns:\n            Optional[float]: Allowance amount in Ether (float) or None on error.\n\n        \"\"\"\n        return self.transfer_service.get_erc20_allowance(\n            owner_address_or_tag, spender_address, token_address_or_name, chain_name\n        )\n\n    def approve_erc20(\n        self,\n        owner_address_or_tag: str,\n        spender_address_or_tag: str,\n        token_address_or_name: str,\n        amount_wei: Wei,\n        chain_name: str = \"gnosis\",\n    ) -&gt; Optional[str]:\n        \"\"\"Approve ERC20 token allowance.\n\n        Args:\n            owner_address_or_tag: Token owner's address or tag.\n            spender_address_or_tag: Spender's address or tag.\n            token_address_or_name: Token address or name.\n            amount_wei: Amount to approve in Wei.\n            chain_name: Target blockchain name.\n\n        Returns:\n            Optional[str]: Transaction hash if successful, None otherwise.\n\n        \"\"\"\n        return self.transfer_service.approve_erc20(\n            owner_address_or_tag,\n            spender_address_or_tag,\n            token_address_or_name,\n            amount_wei,\n            chain_name,\n        )\n\n    def transfer_from_erc20(\n        self,\n        from_address_or_tag: str,\n        sender_address_or_tag: str,\n        recipient_address_or_tag: str,\n        token_address_or_name: str,\n        amount_wei: Wei,\n        chain_name: str = \"gnosis\",\n    ):\n        \"\"\"TransferFrom ERC20 tokens\"\"\"\n        return self.transfer_service.transfer_from_erc20(\n            from_address_or_tag,\n            sender_address_or_tag,\n            recipient_address_or_tag,\n            token_address_or_name,\n            amount_wei,\n            chain_name,\n        )\n\n    async def swap(\n        self,\n        account_address_or_tag: str,\n        amount_eth: Optional[float],\n        sell_token_name: str,\n        buy_token_name: str,\n        chain_name: str = \"gnosis\",\n        order_type: OrderType = OrderType.SELL,\n    ) -&gt; bool:\n        \"\"\"Swap ERC-20 tokens on CowSwap.\n\n        Args:\n            account_address_or_tag: Account address or tag initiating the swap.\n            amount_eth: Amount to swap (sell or buy amount depending on order_type).\n            sell_token_name: Name of the token to sell.\n            buy_token_name: Name of the token to buy.\n            chain_name: Blockchain name (must supports CowSwap, e.g., \"gnosis\").\n            order_type: OrderType.SELL or OrderType.BUY.\n\n        Returns:\n            bool: True if swap order was created and filled successfully.\n\n        \"\"\"\n        return await self.transfer_service.swap(\n            account_address_or_tag,\n            amount_eth,\n            sell_token_name,\n            buy_token_name,\n            chain_name,\n            order_type,\n        )\n\n    def drain(\n        self,\n        from_address_or_tag: str,\n        to_address_or_tag: str = \"master\",\n        chain_name: str = \"gnosis\",\n    ) -&gt; Optional[str]:\n        \"\"\"Drain entire balance of an account to another account.\n\n        Transfers all native currency and known ERC20 tokens.\n\n        Args:\n            from_address_or_tag: Source account address or tag.\n            to_address_or_tag: Destination account address or tag (default: \"master\").\n            chain_name: Target blockchain name.\n\n        Returns:\n            Optional[str]: Summary of the operation or transaction hash of the last transfer.\n\n        \"\"\"\n        return self.transfer_service.drain(from_address_or_tag, to_address_or_tag, chain_name)\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.master_account","title":"<code>master_account</code>  <code>property</code>","text":"<p>Get master account</p>"},{"location":"core/#iwa.core.wallet.Wallet.__init__","title":"<code>__init__()</code>","text":"<p>Initialize wallet.</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize wallet.\"\"\"\n    self.key_storage = KeyStorage()\n    self.account_service = AccountService(self.key_storage)\n    self.balance_service = BalanceService(self.key_storage, self.account_service)\n    self.safe_service = SafeService(self.key_storage, self.account_service)\n    # self.transaction_manager = TransactionManager(self.key_storage, self.account_service)\n    self.transaction_service = TransactionService(self.key_storage, self.account_service)\n\n    self.transfer_service = TransferService(\n        self.key_storage,\n        self.account_service,\n        self.balance_service,\n        self.safe_service,\n        self.transaction_service,\n    )\n    self.plugin_service = PluginService()\n\n    init_db()\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.approve_erc20","title":"<code>approve_erc20(owner_address_or_tag, spender_address_or_tag, token_address_or_name, amount_wei, chain_name='gnosis')</code>","text":"<p>Approve ERC20 token allowance.</p> <p>Parameters:</p> Name Type Description Default <code>owner_address_or_tag</code> <code>str</code> <p>Token owner's address or tag.</p> required <code>spender_address_or_tag</code> <code>str</code> <p>Spender's address or tag.</p> required <code>token_address_or_name</code> <code>str</code> <p>Token address or name.</p> required <code>amount_wei</code> <code>Wei</code> <p>Amount to approve in Wei.</p> required <code>chain_name</code> <code>str</code> <p>Target blockchain name.</p> <code>'gnosis'</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Transaction hash if successful, None otherwise.</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def approve_erc20(\n    self,\n    owner_address_or_tag: str,\n    spender_address_or_tag: str,\n    token_address_or_name: str,\n    amount_wei: Wei,\n    chain_name: str = \"gnosis\",\n) -&gt; Optional[str]:\n    \"\"\"Approve ERC20 token allowance.\n\n    Args:\n        owner_address_or_tag: Token owner's address or tag.\n        spender_address_or_tag: Spender's address or tag.\n        token_address_or_name: Token address or name.\n        amount_wei: Amount to approve in Wei.\n        chain_name: Target blockchain name.\n\n    Returns:\n        Optional[str]: Transaction hash if successful, None otherwise.\n\n    \"\"\"\n    return self.transfer_service.approve_erc20(\n        owner_address_or_tag,\n        spender_address_or_tag,\n        token_address_or_name,\n        amount_wei,\n        chain_name,\n    )\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.drain","title":"<code>drain(from_address_or_tag, to_address_or_tag='master', chain_name='gnosis')</code>","text":"<p>Drain entire balance of an account to another account.</p> <p>Transfers all native currency and known ERC20 tokens.</p> <p>Parameters:</p> Name Type Description Default <code>from_address_or_tag</code> <code>str</code> <p>Source account address or tag.</p> required <code>to_address_or_tag</code> <code>str</code> <p>Destination account address or tag (default: \"master\").</p> <code>'master'</code> <code>chain_name</code> <code>str</code> <p>Target blockchain name.</p> <code>'gnosis'</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Summary of the operation or transaction hash of the last transfer.</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def drain(\n    self,\n    from_address_or_tag: str,\n    to_address_or_tag: str = \"master\",\n    chain_name: str = \"gnosis\",\n) -&gt; Optional[str]:\n    \"\"\"Drain entire balance of an account to another account.\n\n    Transfers all native currency and known ERC20 tokens.\n\n    Args:\n        from_address_or_tag: Source account address or tag.\n        to_address_or_tag: Destination account address or tag (default: \"master\").\n        chain_name: Target blockchain name.\n\n    Returns:\n        Optional[str]: Summary of the operation or transaction hash of the last transfer.\n\n    \"\"\"\n    return self.transfer_service.drain(from_address_or_tag, to_address_or_tag, chain_name)\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.get_accounts_balances","title":"<code>get_accounts_balances(chain_name, token_names=None)</code>","text":"<p>Get accounts data and balances.</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def get_accounts_balances(\n    self, chain_name: str, token_names: Optional[list[str]] = None\n) -&gt; Tuple[dict, Optional[dict]]:\n    \"\"\"Get accounts data and balances.\"\"\"\n    accounts_data = self.account_service.get_account_data()\n    token_names = token_names or []\n\n    if not token_names:\n        return accounts_data, None\n\n    token_balances = {addr: {} for addr in accounts_data.keys()}\n\n    def fetch_balance(addr, t_name):\n        try:\n            if t_name == \"native\":\n                return (\n                    addr,\n                    t_name,\n                    self.balance_service.get_native_balance_eth(addr, chain_name),\n                )\n            else:\n                return (\n                    addr,\n                    t_name,\n                    self.balance_service.get_erc20_balance_eth(addr, t_name, chain_name),\n                )\n        except Exception as e:\n            logger.error(f\"Error fetching {t_name} balance for {addr}: {e}\")\n            return addr, t_name, 0.0\n\n    # Use ThreadPoolExecutor for parallel balance fetching\n    with ThreadPoolExecutor(max_workers=20) as executor:\n        tasks = []\n        for addr in accounts_data.keys():\n            for t_name in token_names:\n                tasks.append(executor.submit(fetch_balance, addr, t_name))\n\n        for future in tasks:\n            addr, t_name, bal = future.result()\n            token_balances[addr][t_name] = bal\n\n    return accounts_data, token_balances\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.get_erc20_allowance","title":"<code>get_erc20_allowance(owner_address_or_tag, spender_address, token_address_or_name, chain_name='gnosis')</code>","text":"<p>Get ERC20 token allowance.</p> <p>Parameters:</p> Name Type Description Default <code>owner_address_or_tag</code> <code>str</code> <p>Token owner's address or tag.</p> required <code>spender_address</code> <code>str</code> <p>Address authorized to spend tokens.</p> required <code>token_address_or_name</code> <code>str</code> <p>Token address or name.</p> required <code>chain_name</code> <code>str</code> <p>Target blockchain name.</p> <code>'gnosis'</code> <p>Returns:</p> Type Description <code>Optional[float]</code> <p>Optional[float]: Allowance amount in Ether (float) or None on error.</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def get_erc20_allowance(\n    self,\n    owner_address_or_tag: str,\n    spender_address: str,\n    token_address_or_name: str,\n    chain_name: str = \"gnosis\",\n) -&gt; Optional[float]:\n    \"\"\"Get ERC20 token allowance.\n\n    Args:\n        owner_address_or_tag: Token owner's address or tag.\n        spender_address: Address authorized to spend tokens.\n        token_address_or_name: Token address or name.\n        chain_name: Target blockchain name.\n\n    Returns:\n        Optional[float]: Allowance amount in Ether (float) or None on error.\n\n    \"\"\"\n    return self.transfer_service.get_erc20_allowance(\n        owner_address_or_tag, spender_address, token_address_or_name, chain_name\n    )\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.get_erc20_balance_eth","title":"<code>get_erc20_balance_eth(account_address_or_tag, token_address_or_name, chain_name='gnosis')</code>","text":"<p>Get ERC20 token balance</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def get_erc20_balance_eth(\n    self, account_address_or_tag: str, token_address_or_name: str, chain_name: str = \"gnosis\"\n) -&gt; Optional[float]:\n    \"\"\"Get ERC20 token balance\"\"\"\n    return self.balance_service.get_erc20_balance_eth(\n        account_address_or_tag, token_address_or_name, chain_name\n    )\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.get_erc20_balance_wei","title":"<code>get_erc20_balance_wei(account_address_or_tag, token_address_or_name, chain_name='gnosis')</code>","text":"<p>Get ERC20 token balance</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def get_erc20_balance_wei(\n    self, account_address_or_tag: str, token_address_or_name: str, chain_name: str = \"gnosis\"\n) -&gt; Optional[Wei]:\n    \"\"\"Get ERC20 token balance\"\"\"\n    return self.balance_service.get_erc20_balance_wei(\n        account_address_or_tag, token_address_or_name, chain_name\n    )\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.get_native_balance_eth","title":"<code>get_native_balance_eth(account_address, chain_name='gnosis')</code>","text":"<p>Get native currency balance</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def get_native_balance_eth(\n    self, account_address: str, chain_name: str = \"gnosis\"\n) -&gt; Optional[float]:\n    \"\"\"Get native currency balance\"\"\"\n    return self.balance_service.get_native_balance_eth(account_address, chain_name)\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.get_native_balance_wei","title":"<code>get_native_balance_wei(account_address, chain_name='gnosis')</code>","text":"<p>Get native currency balance</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def get_native_balance_wei(\n    self, account_address: str, chain_name: str = \"gnosis\"\n) -&gt; Optional[Wei]:\n    \"\"\"Get native currency balance\"\"\"\n    return self.balance_service.get_native_balance_wei(account_address, chain_name)\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.get_token_address","title":"<code>get_token_address(token_address_or_name, chain)</code>","text":"<p>Get token address from address or name</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def get_token_address(\n    self, token_address_or_name: str, chain: SupportedChain\n) -&gt; Optional[EthereumAddress]:\n    \"\"\"Get token address from address or name\"\"\"\n    return self.account_service.get_token_address(token_address_or_name, chain)\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.multi_send","title":"<code>multi_send(from_address_or_tag, transactions, chain_name='gnosis')</code>","text":"<p>Send multiple transactions in a single multisend transaction</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def multi_send(\n    self,\n    from_address_or_tag: str,\n    transactions: list,\n    chain_name: str = \"gnosis\",\n):\n    \"\"\"Send multiple transactions in a single multisend transaction\"\"\"\n    return self.transfer_service.multi_send(from_address_or_tag, transactions, chain_name)\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.send","title":"<code>send(from_address_or_tag, to_address_or_tag, amount_wei, token_address_or_name='native', chain_name='gnosis')</code>","text":"<p>Send native currency or ERC20 tokens.</p> <p>Unified interface for transferring assets.</p> <p>Parameters:</p> Name Type Description Default <code>from_address_or_tag</code> <code>str</code> <p>Sender's address or tag.</p> required <code>to_address_or_tag</code> <code>str</code> <p>Recipient's address or tag.</p> required <code>amount_wei</code> <code>Wei</code> <p>Amount to send in Wei.</p> required <code>token_address_or_name</code> <code>str</code> <p>Token address, name, or \"native\".</p> <code>'native'</code> <code>chain_name</code> <code>str</code> <p>Target blockchain name.</p> <code>'gnosis'</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Transaction hash if successful, None otherwise.</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def send(\n    self,\n    from_address_or_tag: str,\n    to_address_or_tag: str,\n    amount_wei: Wei,\n    token_address_or_name: str = \"native\",\n    chain_name: str = \"gnosis\",\n) -&gt; Optional[str]:\n    \"\"\"Send native currency or ERC20 tokens.\n\n    Unified interface for transferring assets.\n\n    Args:\n        from_address_or_tag: Sender's address or tag.\n        to_address_or_tag: Recipient's address or tag.\n        amount_wei: Amount to send in Wei.\n        token_address_or_name: Token address, name, or \"native\".\n        chain_name: Target blockchain name.\n\n    Returns:\n        Optional[str]: Transaction hash if successful, None otherwise.\n\n    \"\"\"\n    return self.transfer_service.send(\n        from_address_or_tag,\n        to_address_or_tag,\n        amount_wei,\n        token_address_or_name,\n        chain_name,\n    )\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.send_erc20_transfer","title":"<code>send_erc20_transfer(from_address, to_address, amount_wei, token_address, chain_name='gnosis')</code>","text":"<p>Send an ERC20 token transfer.</p> <p>Parameters:</p> Name Type Description Default <code>from_address</code> <code>str</code> <p>Sender's address or tag.</p> required <code>to_address</code> <code>str</code> <p>Recipient's address or tag.</p> required <code>amount_wei</code> <code>Wei</code> <p>Amount to send in Wei.</p> required <code>token_address</code> <code>str</code> <p>Token address or name (e.g., \"OLAS\").</p> required <code>chain_name</code> <code>str</code> <p>Target blockchain name (default: \"gnosis\").</p> <code>'gnosis'</code> <p>Returns:</p> Type Description <code>Tuple[bool, Optional[str]]</code> <p>Tuple containing: - bool: True if transaction was successfully sent (status=1). - Optional[str]: Transaction hash if successful, None otherwise.</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def send_erc20_transfer(\n    self,\n    from_address: str,\n    to_address: str,\n    amount_wei: Wei,\n    token_address: str,\n    chain_name: str = \"gnosis\",\n) -&gt; Tuple[bool, Optional[str]]:\n    \"\"\"Send an ERC20 token transfer.\n\n    Args:\n        from_address: Sender's address or tag.\n        to_address: Recipient's address or tag.\n        amount_wei: Amount to send in Wei.\n        token_address: Token address or name (e.g., \"OLAS\").\n        chain_name: Target blockchain name (default: \"gnosis\").\n\n    Returns:\n        Tuple containing:\n            - bool: True if transaction was successfully sent (status=1).\n            - Optional[str]: Transaction hash if successful, None otherwise.\n\n    \"\"\"\n    tx_hash = self.transfer_service.send(\n        from_address_or_tag=from_address,\n        to_address_or_tag=to_address,\n        amount_wei=amount_wei,\n        token_address_or_name=token_address,\n        chain_name=chain_name,\n    )\n    return bool(tx_hash), tx_hash\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.send_native_transfer","title":"<code>send_native_transfer(from_address, to_address, value_wei, chain_name='gnosis')</code>","text":"<p>Send a native currency transfer (e.g., ETH, xDAI).</p> <p>Parameters:</p> Name Type Description Default <code>from_address</code> <code>str</code> <p>Sender's address or tag.</p> required <code>to_address</code> <code>str</code> <p>Recipient's address or tag.</p> required <code>value_wei</code> <code>Wei</code> <p>Amount to send in Wei.</p> required <code>chain_name</code> <code>str</code> <p>Target blockchain name (default: \"gnosis\").</p> <code>'gnosis'</code> <p>Returns:</p> Type Description <code>Tuple[bool, Optional[str]]</code> <p>Tuple containing: - bool: True if transaction was successfully sent (status=1). - Optional[str]: Transaction hash if successful, None otherwise.</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def send_native_transfer(\n    self,\n    from_address: str,\n    to_address: str,\n    value_wei: Wei,\n    chain_name: str = \"gnosis\",\n) -&gt; Tuple[bool, Optional[str]]:\n    \"\"\"Send a native currency transfer (e.g., ETH, xDAI).\n\n    Args:\n        from_address: Sender's address or tag.\n        to_address: Recipient's address or tag.\n        value_wei: Amount to send in Wei.\n        chain_name: Target blockchain name (default: \"gnosis\").\n\n    Returns:\n        Tuple containing:\n            - bool: True if transaction was successfully sent (status=1).\n            - Optional[str]: Transaction hash if successful, None otherwise.\n\n    \"\"\"\n    tx_hash = self.transfer_service.send(\n        from_address_or_tag=from_address,\n        to_address_or_tag=to_address,\n        amount_wei=value_wei,\n        token_address_or_name=\"native\",\n        chain_name=chain_name,\n    )\n    return bool(tx_hash), tx_hash\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.sign_and_send_transaction","title":"<code>sign_and_send_transaction(transaction, signer_address_or_tag, chain_name='gnosis')</code>","text":"<p>Sign and send a raw transaction dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>dict</code> <p>Dictionary containing transaction parameters.</p> required <code>signer_address_or_tag</code> <code>str</code> <p>Address or tag of the signing account.</p> required <code>chain_name</code> <code>str</code> <p>Target blockchain name (default: \"gnosis\").</p> <code>'gnosis'</code> <p>Returns:</p> Type Description <code>Tuple[bool, dict]</code> <p>Tuple containing: - bool: True if successful. - dict: Transaction receipt or error details.</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def sign_and_send_transaction(\n    self, transaction: dict, signer_address_or_tag: str, chain_name: str = \"gnosis\"\n) -&gt; Tuple[bool, dict]:\n    \"\"\"Sign and send a raw transaction dictionary.\n\n    Args:\n        transaction: Dictionary containing transaction parameters.\n        signer_address_or_tag: Address or tag of the signing account.\n        chain_name: Target blockchain name (default: \"gnosis\").\n\n    Returns:\n        Tuple containing:\n            - bool: True if successful.\n            - dict: Transaction receipt or error details.\n\n    \"\"\"\n    return self.transaction_service.sign_and_send(\n        transaction, signer_address_or_tag, chain_name\n    )\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.swap","title":"<code>swap(account_address_or_tag, amount_eth, sell_token_name, buy_token_name, chain_name='gnosis', order_type=OrderType.SELL)</code>  <code>async</code>","text":"<p>Swap ERC-20 tokens on CowSwap.</p> <p>Parameters:</p> Name Type Description Default <code>account_address_or_tag</code> <code>str</code> <p>Account address or tag initiating the swap.</p> required <code>amount_eth</code> <code>Optional[float]</code> <p>Amount to swap (sell or buy amount depending on order_type).</p> required <code>sell_token_name</code> <code>str</code> <p>Name of the token to sell.</p> required <code>buy_token_name</code> <code>str</code> <p>Name of the token to buy.</p> required <code>chain_name</code> <code>str</code> <p>Blockchain name (must supports CowSwap, e.g., \"gnosis\").</p> <code>'gnosis'</code> <code>order_type</code> <code>OrderType</code> <p>OrderType.SELL or OrderType.BUY.</p> <code>SELL</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if swap order was created and filled successfully.</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>async def swap(\n    self,\n    account_address_or_tag: str,\n    amount_eth: Optional[float],\n    sell_token_name: str,\n    buy_token_name: str,\n    chain_name: str = \"gnosis\",\n    order_type: OrderType = OrderType.SELL,\n) -&gt; bool:\n    \"\"\"Swap ERC-20 tokens on CowSwap.\n\n    Args:\n        account_address_or_tag: Account address or tag initiating the swap.\n        amount_eth: Amount to swap (sell or buy amount depending on order_type).\n        sell_token_name: Name of the token to sell.\n        buy_token_name: Name of the token to buy.\n        chain_name: Blockchain name (must supports CowSwap, e.g., \"gnosis\").\n        order_type: OrderType.SELL or OrderType.BUY.\n\n    Returns:\n        bool: True if swap order was created and filled successfully.\n\n    \"\"\"\n    return await self.transfer_service.swap(\n        account_address_or_tag,\n        amount_eth,\n        sell_token_name,\n        buy_token_name,\n        chain_name,\n        order_type,\n    )\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.transfer_from_erc20","title":"<code>transfer_from_erc20(from_address_or_tag, sender_address_or_tag, recipient_address_or_tag, token_address_or_name, amount_wei, chain_name='gnosis')</code>","text":"<p>TransferFrom ERC20 tokens</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def transfer_from_erc20(\n    self,\n    from_address_or_tag: str,\n    sender_address_or_tag: str,\n    recipient_address_or_tag: str,\n    token_address_or_name: str,\n    amount_wei: Wei,\n    chain_name: str = \"gnosis\",\n):\n    \"\"\"TransferFrom ERC20 tokens\"\"\"\n    return self.transfer_service.transfer_from_erc20(\n        from_address_or_tag,\n        sender_address_or_tag,\n        recipient_address_or_tag,\n        token_address_or_name,\n        amount_wei,\n        chain_name,\n    )\n</code></pre>"},{"location":"core/#transaction-service","title":"Transaction Service","text":""},{"location":"core/#iwa.core.services.transaction","title":"<code>iwa.core.services.transaction</code>","text":"<p>Transaction service module.</p>"},{"location":"core/#iwa.core.services.transaction.TransactionService","title":"<code>TransactionService</code>","text":"<p>Manages transaction lifecycle: signing, sending, retrying.</p> Source code in <code>src/iwa/core/services/transaction.py</code> <pre><code>class TransactionService:\n    \"\"\"Manages transaction lifecycle: signing, sending, retrying.\"\"\"\n\n    def __init__(self, key_storage: KeyStorage, account_service: AccountService):\n        \"\"\"Initialize TransactionService.\"\"\"\n        self.key_storage = key_storage\n        self.account_service = account_service\n\n    def sign_and_send(  # noqa: C901\n        self, transaction: dict, signer_address_or_tag: str, chain_name: str = \"gnosis\"\n    ) -&gt; Tuple[bool, Dict]:\n        \"\"\"Sign and send a transaction with retry logic for gas.\"\"\"\n        chain_interface = ChainInterfaces().get(chain_name)\n        tx = dict(transaction)\n        max_retries = 3\n\n        # Ensure nonce is set if not present\n        if \"nonce\" not in tx:\n            signer_account = self.account_service.resolve_account(signer_address_or_tag)\n            if not signer_account:\n                logger.error(f\"Signer {signer_address_or_tag} not found\")\n                return False, {}\n            tx[\"nonce\"] = chain_interface.web3.eth.get_transaction_count(signer_account.address)\n\n        if \"chainId\" not in tx:\n            tx[\"chainId\"] = chain_interface.chain.chain_id\n\n        for attempt in range(1, max_retries + 1):\n            try:\n                # Sign\n                signed_txn = self.key_storage.sign_transaction(tx, signer_address_or_tag)\n\n                # Send\n                txn_hash = chain_interface.web3.eth.send_raw_transaction(signed_txn.raw_transaction)\n\n                # Wait\n                receipt = chain_interface.web3.eth.wait_for_transaction_receipt(txn_hash)\n\n                if receipt and getattr(receipt, \"status\", None) == 1:\n                    signer_account = self.account_service.resolve_account(signer_address_or_tag)\n                    chain_interface.wait_for_no_pending_tx(signer_account.address)\n                    logger.info(f\"Transaction sent successfully. Tx Hash: {txn_hash.hex()}\")\n\n                    # Log the transaction to the database\n                    try:\n                        from_addr = signer_account.address\n                        to_addr = tx.get(\"to\", \"\")\n                        value_wei = tx.get(\"value\", 0)\n                        gas_used = getattr(receipt, \"gasUsed\", 0)\n                        gas_price = tx.get(\"gasPrice\", tx.get(\"maxFeePerGas\", 0))\n                        gas_cost_wei = gas_used * gas_price if gas_price else 0\n\n                        log_transaction(\n                            tx_hash=txn_hash.hex(),\n                            from_addr=from_addr,\n                            to_addr=to_addr,\n                            token=\"NATIVE\",  # Generic, will be overwritten by transfer service for ERC20\n                            amount_wei=value_wei,\n                            chain=chain_name,\n                            from_tag=signer_account.tag if hasattr(signer_account, \"tag\") else None,\n                            gas_cost=str(gas_cost_wei) if gas_cost_wei else None,\n                            tags=[\"olas\"] if \"olas\" in str(tx.get(\"to\", \"\")).lower() else None,\n                        )\n                    except Exception as log_err:\n                        logger.warning(f\"Failed to log transaction: {log_err}\")\n\n                    return True, receipt\n\n                # Transaction reverted - log details for debugging\n                print(\"[TX-DEBUG] Transaction REVERTED (status=0)\", flush=True)\n                print(f\"[TX-DEBUG] Tx Hash: {txn_hash.hex()}\", flush=True)\n                print(f\"[TX-DEBUG] To: {tx.get('to', 'Unknown')}\", flush=True)\n                print(f\"[TX-DEBUG] Gas used: {getattr(receipt, 'gasUsed', 'Unknown')}\", flush=True)\n                logger.error(\"Transaction failed (status 0).\")\n                return False, {}\n\n            except web3_exceptions.Web3RPCError as e:\n                err_text = str(e)\n                if self._is_gas_too_low_error(err_text) and attempt &lt; max_retries:\n                    logger.warning(\n                        f\"Gas too low error detected. Retrying with increased gas (Attempt {attempt}/{max_retries})...\"\n                    )\n                    current_gas = int(tx.get(\"gas\", 30_000))\n                    tx[\"gas\"] = int(current_gas * 1.5)\n                    time.sleep(0.5 * attempt)  # backoff\n                    continue\n                else:\n                    logger.exception(f\"Error sending transaction: {e}\")\n                    return False, {}\n\n            except Exception as e:\n                # Attempt RPC rotation on failure if it's likely a connection/node issue\n                # Differentiating is hard, so we might rotate on unknown errors too if we haven't exhausted attempts yet\n                if attempt &lt; max_retries:\n                    logger.warning(f\"Error encountered: {e}. Attempting to rotate RPC...\")\n                    rotated = chain_interface.rotate_rpc()\n                    if rotated:\n                        logger.info(\"Retrying with new RPC...\")\n                        time.sleep(0.5 * attempt)\n                        continue\n\n                logger.exception(f\"Unexpected error sending transaction: {e}\")\n                return False, {}\n\n        return False, {}\n\n    def _is_gas_too_low_error(self, err_text: str) -&gt; bool:\n        \"\"\"Check if error is due to low gas.\"\"\"\n        low_gas_signals = [\n            \"feetoolow\",\n            \"intrinsic gas too low\",\n            \"replacement transaction underpriced\",\n        ]\n        text = (err_text or \"\").lower()\n        return any(sig in text for sig in low_gas_signals)\n</code></pre>"},{"location":"core/#iwa.core.services.transaction.TransactionService.__init__","title":"<code>__init__(key_storage, account_service)</code>","text":"<p>Initialize TransactionService.</p> Source code in <code>src/iwa/core/services/transaction.py</code> <pre><code>def __init__(self, key_storage: KeyStorage, account_service: AccountService):\n    \"\"\"Initialize TransactionService.\"\"\"\n    self.key_storage = key_storage\n    self.account_service = account_service\n</code></pre>"},{"location":"core/#iwa.core.services.transaction.TransactionService.sign_and_send","title":"<code>sign_and_send(transaction, signer_address_or_tag, chain_name='gnosis')</code>","text":"<p>Sign and send a transaction with retry logic for gas.</p> Source code in <code>src/iwa/core/services/transaction.py</code> <pre><code>def sign_and_send(  # noqa: C901\n    self, transaction: dict, signer_address_or_tag: str, chain_name: str = \"gnosis\"\n) -&gt; Tuple[bool, Dict]:\n    \"\"\"Sign and send a transaction with retry logic for gas.\"\"\"\n    chain_interface = ChainInterfaces().get(chain_name)\n    tx = dict(transaction)\n    max_retries = 3\n\n    # Ensure nonce is set if not present\n    if \"nonce\" not in tx:\n        signer_account = self.account_service.resolve_account(signer_address_or_tag)\n        if not signer_account:\n            logger.error(f\"Signer {signer_address_or_tag} not found\")\n            return False, {}\n        tx[\"nonce\"] = chain_interface.web3.eth.get_transaction_count(signer_account.address)\n\n    if \"chainId\" not in tx:\n        tx[\"chainId\"] = chain_interface.chain.chain_id\n\n    for attempt in range(1, max_retries + 1):\n        try:\n            # Sign\n            signed_txn = self.key_storage.sign_transaction(tx, signer_address_or_tag)\n\n            # Send\n            txn_hash = chain_interface.web3.eth.send_raw_transaction(signed_txn.raw_transaction)\n\n            # Wait\n            receipt = chain_interface.web3.eth.wait_for_transaction_receipt(txn_hash)\n\n            if receipt and getattr(receipt, \"status\", None) == 1:\n                signer_account = self.account_service.resolve_account(signer_address_or_tag)\n                chain_interface.wait_for_no_pending_tx(signer_account.address)\n                logger.info(f\"Transaction sent successfully. Tx Hash: {txn_hash.hex()}\")\n\n                # Log the transaction to the database\n                try:\n                    from_addr = signer_account.address\n                    to_addr = tx.get(\"to\", \"\")\n                    value_wei = tx.get(\"value\", 0)\n                    gas_used = getattr(receipt, \"gasUsed\", 0)\n                    gas_price = tx.get(\"gasPrice\", tx.get(\"maxFeePerGas\", 0))\n                    gas_cost_wei = gas_used * gas_price if gas_price else 0\n\n                    log_transaction(\n                        tx_hash=txn_hash.hex(),\n                        from_addr=from_addr,\n                        to_addr=to_addr,\n                        token=\"NATIVE\",  # Generic, will be overwritten by transfer service for ERC20\n                        amount_wei=value_wei,\n                        chain=chain_name,\n                        from_tag=signer_account.tag if hasattr(signer_account, \"tag\") else None,\n                        gas_cost=str(gas_cost_wei) if gas_cost_wei else None,\n                        tags=[\"olas\"] if \"olas\" in str(tx.get(\"to\", \"\")).lower() else None,\n                    )\n                except Exception as log_err:\n                    logger.warning(f\"Failed to log transaction: {log_err}\")\n\n                return True, receipt\n\n            # Transaction reverted - log details for debugging\n            print(\"[TX-DEBUG] Transaction REVERTED (status=0)\", flush=True)\n            print(f\"[TX-DEBUG] Tx Hash: {txn_hash.hex()}\", flush=True)\n            print(f\"[TX-DEBUG] To: {tx.get('to', 'Unknown')}\", flush=True)\n            print(f\"[TX-DEBUG] Gas used: {getattr(receipt, 'gasUsed', 'Unknown')}\", flush=True)\n            logger.error(\"Transaction failed (status 0).\")\n            return False, {}\n\n        except web3_exceptions.Web3RPCError as e:\n            err_text = str(e)\n            if self._is_gas_too_low_error(err_text) and attempt &lt; max_retries:\n                logger.warning(\n                    f\"Gas too low error detected. Retrying with increased gas (Attempt {attempt}/{max_retries})...\"\n                )\n                current_gas = int(tx.get(\"gas\", 30_000))\n                tx[\"gas\"] = int(current_gas * 1.5)\n                time.sleep(0.5 * attempt)  # backoff\n                continue\n            else:\n                logger.exception(f\"Error sending transaction: {e}\")\n                return False, {}\n\n        except Exception as e:\n            # Attempt RPC rotation on failure if it's likely a connection/node issue\n            # Differentiating is hard, so we might rotate on unknown errors too if we haven't exhausted attempts yet\n            if attempt &lt; max_retries:\n                logger.warning(f\"Error encountered: {e}. Attempting to rotate RPC...\")\n                rotated = chain_interface.rotate_rpc()\n                if rotated:\n                    logger.info(\"Retrying with new RPC...\")\n                    time.sleep(0.5 * attempt)\n                    continue\n\n            logger.exception(f\"Unexpected error sending transaction: {e}\")\n            return False, {}\n\n    return False, {}\n</code></pre>"},{"location":"core/#chain-interface","title":"Chain Interface","text":""},{"location":"core/#iwa.core.chain","title":"<code>iwa.core.chain</code>","text":"<p>Chain interaction helpers.</p>"},{"location":"core/#iwa.core.chain.ChainInterface","title":"<code>ChainInterface</code>","text":"<p>ChainInterface with rate limiting, retry logic, and RPC rotation support.</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>class ChainInterface:\n    \"\"\"ChainInterface with rate limiting, retry logic, and RPC rotation support.\"\"\"\n\n    # Default retry settings\n    DEFAULT_MAX_RETRIES = 3\n    DEFAULT_RETRY_DELAY = 0.5  # Base delay in seconds (exponential backoff)\n\n    def __init__(self, chain: Union[SupportedChain, str] = None):\n        \"\"\"Initialize ChainInterface.\"\"\"\n        if chain is None:\n            chain = Gnosis()\n        if isinstance(chain, str):\n            chain: SupportedChain = getattr(SupportedChains(), chain.lower())\n\n        self.chain = chain\n        self._rate_limiter = get_rate_limiter(chain.name)\n        self._current_rpc_index = 0\n        self._rpc_failure_counts: Dict[int, int] = {}  # Track failures per RPC\n\n        if self.chain.rpc and self.chain.rpc.startswith(\"http://\"):\n            logger.warning(\n                f\"Using insecure RPC URL for {self.chain.name}: {self.chain.rpc}. Please use HTTPS.\"\n            )\n\n        self._init_web3()\n\n    def _init_web3(self):\n        \"\"\"Initialize Web3 with current RPC.\"\"\"\n        rpc_url = self.chain.rpcs[self._current_rpc_index] if self.chain.rpcs else \"\"\n        raw_web3 = Web3(Web3.HTTPProvider(rpc_url, request_kwargs={\"timeout\": DEFAULT_RPC_TIMEOUT}))\n        self.web3 = RateLimitedWeb3(raw_web3, self._rate_limiter, self)\n\n    def _is_rate_limit_error(self, error: Exception) -&gt; bool:\n        \"\"\"Check if error is a rate limit (429) error.\"\"\"\n        err_text = str(error).lower()\n        rate_limit_signals = [\"429\", \"rate limit\", \"too many requests\", \"ratelimit\"]\n        return any(signal in err_text for signal in rate_limit_signals)\n\n    def _is_connection_error(self, error: Exception) -&gt; bool:\n        \"\"\"Check if error is a connection/network error.\n\n        These errors indicate the RPC may be broken or unreachable.\n        \"\"\"\n        err_text = str(error).lower()\n        connection_signals = [\n            \"timeout\",\n            \"timed out\",\n            \"connection refused\",\n            \"connection reset\",\n            \"connection error\",\n            \"connection aborted\",\n            \"name resolution\",\n            \"dns\",\n            \"no route to host\",\n            \"network unreachable\",\n            \"max retries exceeded\",\n            \"read timeout\",\n            \"connect timeout\",\n            \"remote end closed\",\n            \"broken pipe\",\n        ]\n        return any(signal in err_text for signal in connection_signals)\n\n    def _is_server_error(self, error: Exception) -&gt; bool:\n        \"\"\"Check if error is a server-side error (5xx).\"\"\"\n        err_text = str(error).lower()\n        server_error_signals = [\n            \"500\",\n            \"502\",\n            \"503\",\n            \"504\",\n            \"internal server error\",\n            \"bad gateway\",\n            \"service unavailable\",\n            \"gateway timeout\",\n        ]\n        return any(signal in err_text for signal in server_error_signals)\n\n    def _handle_rpc_error(self, error: Exception) -&gt; Dict[str, Union[bool, int]]:\n        \"\"\"Handle RPC errors with smart rotation and retry logic.\n\n        Analyzes the exception to determine if it's a rate limit, connection,\n        or server error. Decides whether to rotate the RPC provider or back off.\n\n        Args:\n            error: The exception raised during the RPC call.\n\n        Returns:\n            A dictionary containing:\n                - is_rate_limit (bool): True if error is 429/Rate Limit.\n                - is_connection_error (bool): True if network/connection related.\n                - is_server_error (bool): True if 5xx server error.\n                - rotated (bool): True if RPC rotation was performed.\n                - should_retry (bool): True if the operation should be retried.\n\n        \"\"\"\n        result: Dict[str, Union[bool, int]] = {\n            \"is_rate_limit\": self._is_rate_limit_error(error),\n            \"is_connection_error\": self._is_connection_error(error),\n            \"is_server_error\": self._is_server_error(error),\n            \"rotated\": False,\n            \"should_retry\": False,\n        }\n\n        # Track failure for current RPC\n        self._rpc_failure_counts[self._current_rpc_index] = (\n            self._rpc_failure_counts.get(self._current_rpc_index, 0) + 1\n        )\n\n        # Determine if we should try to rotate\n        should_rotate = result[\"is_rate_limit\"] or result[\"is_connection_error\"]\n\n        if should_rotate:\n            error_type = \"rate limit\" if result[\"is_rate_limit\"] else \"connection\"\n            logger.warning(\n                f\"RPC {error_type} error on {self.chain.name} \"\n                f\"(RPC #{self._current_rpc_index}): {error}\"\n            )\n\n            if self.rotate_rpc():\n                result[\"rotated\"] = True\n                result[\"should_retry\"] = True\n                logger.info(f\"Rotated to RPC #{self._current_rpc_index} for {self.chain.name}\")\n            else:\n                # No other RPCs available\n                if result[\"is_rate_limit\"]:\n                    self._rate_limiter.trigger_backoff(seconds=5.0)\n                    result[\"should_retry\"] = True\n                    logger.warning(\"No other RPCs available, triggered backoff\")\n\n        elif result[\"is_server_error\"]:\n            logger.warning(f\"Server error on {self.chain.name}: {error}\")\n            result[\"should_retry\"] = True  # Server errors are often transient\n\n        return result\n\n    def rotate_rpc(self) -&gt; bool:\n        \"\"\"Rotate to the next available RPC.\n\n        Returns:\n            True if rotation succeeded, False if no other RPCs available.\n\n        \"\"\"\n        if not self.chain.rpcs or len(self.chain.rpcs) &lt;= 1:\n            return False\n\n        original_index = self._current_rpc_index\n        attempts = 0\n\n        while attempts &lt; len(self.chain.rpcs) - 1:\n            self._current_rpc_index = (self._current_rpc_index + 1) % len(self.chain.rpcs)\n            attempts += 1\n\n            # Skip RPCs that have failed too many times recently\n            if self._rpc_failure_counts.get(self._current_rpc_index, 0) &gt;= 5:\n                continue\n\n            logger.info(f\"Rotating RPC for {self.chain.name} to index {self._current_rpc_index}\")\n            self._init_web3()\n\n            # Verify the new RPC works\n            if self.check_rpc_health():\n                return True\n            else:\n                logger.warning(f\"RPC at index {self._current_rpc_index} failed health check\")\n                self._rpc_failure_counts[self._current_rpc_index] = (\n                    self._rpc_failure_counts.get(self._current_rpc_index, 0) + 1\n                )\n\n        # All RPCs failed, restore original\n        self._current_rpc_index = original_index\n        self._init_web3()\n        return False\n\n    def check_rpc_health(self) -&gt; bool:\n        \"\"\"Check if the current RPC is healthy.\n\n        Returns:\n            True if RPC responds correctly, False otherwise.\n\n        \"\"\"\n        try:\n            # Simple block number request to verify connectivity\n            block = self.web3._web3.eth.block_number\n            return block is not None and block &gt; 0\n        except Exception as e:\n            logger.debug(f\"RPC health check failed: {e}\")\n            return False\n\n    def with_retry(\n        self,\n        operation: Callable[[], T],\n        max_retries: Optional[int] = None,\n        operation_name: str = \"operation\",\n    ) -&gt; T:\n        \"\"\"Execute an operation with retry logic.\n\n        Automatically handles:\n        - Rate limit errors (with exponential backoff)\n        - Connection errors (with RPC rotation)\n        - Server errors (with standard retry)\n\n        Args:\n            operation: Callable that performs the RPC operation.\n            max_retries: Maximum retry attempts (default: DEFAULT_MAX_RETRIES).\n            operation_name: Name for logging purposes.\n\n        Returns:\n            The result of the operation.\n\n        Raises:\n            Exception: If all retries are exhausted.\n\n        \"\"\"\n        if max_retries is None:\n            max_retries = self.DEFAULT_MAX_RETRIES\n\n        last_error = None\n\n        for attempt in range(max_retries + 1):\n            try:\n                return operation()\n            except Exception as e:\n                last_error = e\n                result = self._handle_rpc_error(e)\n\n                if not result[\"should_retry\"] or attempt &gt;= max_retries:\n                    logger.error(f\"{operation_name} failed after {attempt + 1} attempts: {e}\")\n                    raise\n\n                # Exponential backoff\n                delay = self.DEFAULT_RETRY_DELAY * (2**attempt)\n                logger.info(\n                    f\"{operation_name} attempt {attempt + 1} failed, retrying in {delay:.1f}s...\"\n                )\n                time.sleep(delay)\n\n        if last_error:\n            raise last_error\n        # Fallback if loop finishes without error (should cover based on logic)\n        raise RuntimeError(f\"{operation_name} failed unexpectedly\")\n\n    def is_contract(self, address: str) -&gt; bool:\n        \"\"\"Check if address is a contract\"\"\"\n        code = self.web3.eth.get_code(address)\n        return code != b\"\"\n\n    @property\n    def tokens(self) -&gt; Dict[str, EthereumAddress]:\n        \"\"\"Get all tokens for this chain (default + custom).\"\"\"\n        defaults = self.chain.tokens.copy()\n\n        config = Config()\n        if config.core and config.core.custom_tokens:\n            # Look for chain name (case insensitive match?)\n            # Config keys usually string.\n            custom = config.core.custom_tokens.get(self.chain.name.lower(), {})\n            if not custom:\n                custom = config.core.custom_tokens.get(self.chain.name, {})\n\n            defaults.update(custom)\n\n        return defaults\n\n    def get_token_symbol(self, address: str) -&gt; str:\n        \"\"\"Get token symbol for an address.\"\"\"\n        # 1. Check known tokens in Chain model\n        for symbol, addr in self.chain.tokens.items():\n            if addr.lower() == address.lower():\n                return symbol\n\n        # 2. Try to fetch from chain\n        try:\n            from iwa.core.contracts.erc20 import ERC20Contract\n\n            erc20 = ERC20Contract(address, self.chain.name.lower())\n            return erc20.symbol or address[:6] + \"...\" + address[-4:]\n        except Exception:\n            return address[:6] + \"...\" + address[-4:]\n\n    def get_token_decimals(self, address: str) -&gt; int:\n        \"\"\"Get token decimals for an address.\"\"\"\n        try:\n            from iwa.core.contracts.erc20 import ERC20Contract\n\n            erc20 = ERC20Contract(address, self.chain.name.lower())\n            return erc20.decimals if erc20.decimals is not None else 18\n        except Exception:\n            return 18\n\n    def get_native_balance_wei(self, address: str):\n        \"\"\"Get the native balance in wei\"\"\"\n        return self.web3.eth.get_balance(address)\n\n    def get_native_balance_eth(self, address: str):\n        \"\"\"Get the native balance in ether\"\"\"\n        balance_wei = self.get_native_balance_wei(address)\n        balance_ether = self.web3.from_wei(balance_wei, \"ether\")\n        return balance_ether\n\n    # NOTE: sign_and_send_transaction was removed for security reasons.\n    # Use TransactionService.sign_and_send() instead, which handles signing internally\n    # without exposing private keys.\n\n    def estimate_gas(self, built_method: Callable, tx_params: Dict[str, Union[str, int]]) -&gt; int:\n        \"\"\"Estimate gas for a contract function call.\n\n        For contract addresses (e.g., Safe multisigs), gas estimation cannot be done\n        directly as the transaction will be executed by the Safe. Returns 0 in this case.\n\n        Args:\n            built_method: The web3 contract function to estimate gas for.\n            tx_params: Dictionary containing transaction parameters (from, value, etc.).\n\n        Returns:\n            int: Estimated gas limit or 0 if estimation is skipped.\n\n        \"\"\"\n        from_address = tx_params[\"from\"]\n        value = int(tx_params.get(\"value\", 0))  # Ensure value is int\n\n        if self.is_contract(str(from_address)):\n            # Cannot estimate gas for contract callers (e.g., Safe multisig)\n            # The actual gas will be determined when the Safe executes the tx\n            logger.debug(f\"Skipping gas estimation for contract caller {str(from_address)[:10]}...\")\n            return 0\n\n        try:\n            estimated_gas = built_method.estimate_gas({\"from\": from_address, \"value\": value})\n            # Add 10% buffer for safety\n            return int(estimated_gas * 1.1)\n        except Exception as e:\n            logger.warning(f\"Gas estimation failed: {e}\")\n            # Return a reasonable default for most contract calls\n            return 500_000\n\n    def calculate_transaction_params(\n        self, built_method: Callable, tx_params: Dict[str, Union[str, int]]\n    ) -&gt; Dict[str, Union[str, int]]:\n        \"\"\"Calculate transaction parameters for a contract function call.\n\n        Args:\n            built_method: The web3 contract function.\n            tx_params: Base transaction parameters.\n\n        Returns:\n            Dict containing full transaction parameters including nonce, gas, and gasPrice.\n\n        \"\"\"\n        params = {\n            \"from\": tx_params[\"from\"],\n            \"value\": tx_params.get(\"value\", 0),\n            \"nonce\": self.web3.eth.get_transaction_count(tx_params[\"from\"]),\n            \"gas\": self.estimate_gas(built_method, tx_params),\n            \"gasPrice\": self.web3.eth.gas_price,\n        }\n        return params\n\n    def wait_for_no_pending_tx(\n        self, from_address: str, max_wait_seconds: int = 60, poll_interval: float = 2.0\n    ):\n        \"\"\"Wait for no pending transactions for a specified time.\"\"\"\n        start_time = time.time()\n        while time.time() - start_time &lt; max_wait_seconds:\n            latest_nonce = self.web3.eth.get_transaction_count(\n                from_address, block_identifier=\"latest\"\n            )\n            pending_nonce = self.web3.eth.get_transaction_count(\n                from_address, block_identifier=\"pending\"\n            )\n\n            if pending_nonce == latest_nonce:\n                return True\n\n            time.sleep(poll_interval)\n\n        return False\n\n    def send_native_transfer(\n        self,\n        from_address: str,\n        to_address: EthereumAddress,\n        value_wei: int,\n        sign_callback: Callable[[dict], SignedTransaction],\n    ) -&gt; Tuple[bool, Optional[str]]:\n        \"\"\"Send native currency transaction with retry logic.\n\n        Automatically retries on transient errors with RPC rotation.\n        \"\"\"\n\n        def _do_transfer() -&gt; Tuple[bool, Optional[str]]:\n            tx = {\n                \"from\": from_address,\n                \"to\": to_address,\n                \"value\": value_wei,\n                \"nonce\": self.web3.eth.get_transaction_count(from_address),\n                \"chainId\": self.chain.chain_id,\n            }\n\n            balance_wei = self.get_native_balance_wei(from_address)\n            gas_price = self.web3.eth.gas_price\n            gas_estimate = self.web3.eth.estimate_gas(tx)\n            required_wei = value_wei + (gas_estimate * gas_price)\n\n            if balance_wei &lt; required_wei:\n                logger.error(\n                    f\"Insufficient balance. \"\n                    f\"Balance: {self.web3.from_wei(balance_wei, 'ether'):.4f} \"\n                    f\"{self.chain.native_currency}, \"\n                    f\"Required: {self.web3.from_wei(required_wei, 'ether'):.4f} \"\n                    f\"{self.chain.native_currency}\"\n                )\n                return False, None\n\n            tx[\"gas\"] = gas_estimate\n            tx[\"gasPrice\"] = gas_price\n\n            signed_tx = sign_callback(tx)\n            txn_hash = self.web3.eth.send_raw_transaction(signed_tx.raw_transaction)\n            receipt = self.web3.eth.wait_for_transaction_receipt(txn_hash)\n\n            # Use status from receipt, handle both object and dict\n            status = getattr(receipt, \"status\", None)\n            if status is None and isinstance(receipt, dict):\n                status = receipt.get(\"status\")\n\n            if receipt and status == 1:\n                self.wait_for_no_pending_tx(from_address)\n                logger.info(f\"Transaction sent successfully. Tx Hash: {txn_hash.hex()}\")\n                return True, receipt[\"transactionHash\"].hex()\n\n            logger.error(\"Transaction failed (status != 1)\")\n            return False, None\n\n        try:\n            return self.with_retry(\n                _do_transfer,\n                operation_name=f\"native_transfer to {str(to_address)[:10]}...\",\n            )\n        except Exception as e:\n            logger.exception(f\"Native transfer failed: {e}\")\n            return False, None\n\n    def get_token_address(self, token_name: str) -&gt; Optional[EthereumAddress]:\n        \"\"\"Get token address by name\"\"\"\n        return self.chain.get_token_address(token_name)\n\n    def get_contract_address(self, contract_name: str) -&gt; Optional[EthereumAddress]:\n        \"\"\"Get contract address by name from the chain's contracts mapping.\"\"\"\n        return self.chain.contracts.get(contract_name)\n\n    def reset_rpc_failure_counts(self):\n        \"\"\"Reset RPC failure tracking. Call periodically to allow retrying failed RPCs.\"\"\"\n        self._rpc_failure_counts.clear()\n        logger.debug(\"Reset RPC failure counts\")\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.tokens","title":"<code>tokens</code>  <code>property</code>","text":"<p>Get all tokens for this chain (default + custom).</p>"},{"location":"core/#iwa.core.chain.ChainInterface.__init__","title":"<code>__init__(chain=None)</code>","text":"<p>Initialize ChainInterface.</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def __init__(self, chain: Union[SupportedChain, str] = None):\n    \"\"\"Initialize ChainInterface.\"\"\"\n    if chain is None:\n        chain = Gnosis()\n    if isinstance(chain, str):\n        chain: SupportedChain = getattr(SupportedChains(), chain.lower())\n\n    self.chain = chain\n    self._rate_limiter = get_rate_limiter(chain.name)\n    self._current_rpc_index = 0\n    self._rpc_failure_counts: Dict[int, int] = {}  # Track failures per RPC\n\n    if self.chain.rpc and self.chain.rpc.startswith(\"http://\"):\n        logger.warning(\n            f\"Using insecure RPC URL for {self.chain.name}: {self.chain.rpc}. Please use HTTPS.\"\n        )\n\n    self._init_web3()\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.calculate_transaction_params","title":"<code>calculate_transaction_params(built_method, tx_params)</code>","text":"<p>Calculate transaction parameters for a contract function call.</p> <p>Parameters:</p> Name Type Description Default <code>built_method</code> <code>Callable</code> <p>The web3 contract function.</p> required <code>tx_params</code> <code>Dict[str, Union[str, int]]</code> <p>Base transaction parameters.</p> required <p>Returns:</p> Type Description <code>Dict[str, Union[str, int]]</code> <p>Dict containing full transaction parameters including nonce, gas, and gasPrice.</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def calculate_transaction_params(\n    self, built_method: Callable, tx_params: Dict[str, Union[str, int]]\n) -&gt; Dict[str, Union[str, int]]:\n    \"\"\"Calculate transaction parameters for a contract function call.\n\n    Args:\n        built_method: The web3 contract function.\n        tx_params: Base transaction parameters.\n\n    Returns:\n        Dict containing full transaction parameters including nonce, gas, and gasPrice.\n\n    \"\"\"\n    params = {\n        \"from\": tx_params[\"from\"],\n        \"value\": tx_params.get(\"value\", 0),\n        \"nonce\": self.web3.eth.get_transaction_count(tx_params[\"from\"]),\n        \"gas\": self.estimate_gas(built_method, tx_params),\n        \"gasPrice\": self.web3.eth.gas_price,\n    }\n    return params\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.check_rpc_health","title":"<code>check_rpc_health()</code>","text":"<p>Check if the current RPC is healthy.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if RPC responds correctly, False otherwise.</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def check_rpc_health(self) -&gt; bool:\n    \"\"\"Check if the current RPC is healthy.\n\n    Returns:\n        True if RPC responds correctly, False otherwise.\n\n    \"\"\"\n    try:\n        # Simple block number request to verify connectivity\n        block = self.web3._web3.eth.block_number\n        return block is not None and block &gt; 0\n    except Exception as e:\n        logger.debug(f\"RPC health check failed: {e}\")\n        return False\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.estimate_gas","title":"<code>estimate_gas(built_method, tx_params)</code>","text":"<p>Estimate gas for a contract function call.</p> <p>For contract addresses (e.g., Safe multisigs), gas estimation cannot be done directly as the transaction will be executed by the Safe. Returns 0 in this case.</p> <p>Parameters:</p> Name Type Description Default <code>built_method</code> <code>Callable</code> <p>The web3 contract function to estimate gas for.</p> required <code>tx_params</code> <code>Dict[str, Union[str, int]]</code> <p>Dictionary containing transaction parameters (from, value, etc.).</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Estimated gas limit or 0 if estimation is skipped.</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def estimate_gas(self, built_method: Callable, tx_params: Dict[str, Union[str, int]]) -&gt; int:\n    \"\"\"Estimate gas for a contract function call.\n\n    For contract addresses (e.g., Safe multisigs), gas estimation cannot be done\n    directly as the transaction will be executed by the Safe. Returns 0 in this case.\n\n    Args:\n        built_method: The web3 contract function to estimate gas for.\n        tx_params: Dictionary containing transaction parameters (from, value, etc.).\n\n    Returns:\n        int: Estimated gas limit or 0 if estimation is skipped.\n\n    \"\"\"\n    from_address = tx_params[\"from\"]\n    value = int(tx_params.get(\"value\", 0))  # Ensure value is int\n\n    if self.is_contract(str(from_address)):\n        # Cannot estimate gas for contract callers (e.g., Safe multisig)\n        # The actual gas will be determined when the Safe executes the tx\n        logger.debug(f\"Skipping gas estimation for contract caller {str(from_address)[:10]}...\")\n        return 0\n\n    try:\n        estimated_gas = built_method.estimate_gas({\"from\": from_address, \"value\": value})\n        # Add 10% buffer for safety\n        return int(estimated_gas * 1.1)\n    except Exception as e:\n        logger.warning(f\"Gas estimation failed: {e}\")\n        # Return a reasonable default for most contract calls\n        return 500_000\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.get_contract_address","title":"<code>get_contract_address(contract_name)</code>","text":"<p>Get contract address by name from the chain's contracts mapping.</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def get_contract_address(self, contract_name: str) -&gt; Optional[EthereumAddress]:\n    \"\"\"Get contract address by name from the chain's contracts mapping.\"\"\"\n    return self.chain.contracts.get(contract_name)\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.get_native_balance_eth","title":"<code>get_native_balance_eth(address)</code>","text":"<p>Get the native balance in ether</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def get_native_balance_eth(self, address: str):\n    \"\"\"Get the native balance in ether\"\"\"\n    balance_wei = self.get_native_balance_wei(address)\n    balance_ether = self.web3.from_wei(balance_wei, \"ether\")\n    return balance_ether\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.get_native_balance_wei","title":"<code>get_native_balance_wei(address)</code>","text":"<p>Get the native balance in wei</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def get_native_balance_wei(self, address: str):\n    \"\"\"Get the native balance in wei\"\"\"\n    return self.web3.eth.get_balance(address)\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.get_token_address","title":"<code>get_token_address(token_name)</code>","text":"<p>Get token address by name</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def get_token_address(self, token_name: str) -&gt; Optional[EthereumAddress]:\n    \"\"\"Get token address by name\"\"\"\n    return self.chain.get_token_address(token_name)\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.get_token_decimals","title":"<code>get_token_decimals(address)</code>","text":"<p>Get token decimals for an address.</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def get_token_decimals(self, address: str) -&gt; int:\n    \"\"\"Get token decimals for an address.\"\"\"\n    try:\n        from iwa.core.contracts.erc20 import ERC20Contract\n\n        erc20 = ERC20Contract(address, self.chain.name.lower())\n        return erc20.decimals if erc20.decimals is not None else 18\n    except Exception:\n        return 18\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.get_token_symbol","title":"<code>get_token_symbol(address)</code>","text":"<p>Get token symbol for an address.</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def get_token_symbol(self, address: str) -&gt; str:\n    \"\"\"Get token symbol for an address.\"\"\"\n    # 1. Check known tokens in Chain model\n    for symbol, addr in self.chain.tokens.items():\n        if addr.lower() == address.lower():\n            return symbol\n\n    # 2. Try to fetch from chain\n    try:\n        from iwa.core.contracts.erc20 import ERC20Contract\n\n        erc20 = ERC20Contract(address, self.chain.name.lower())\n        return erc20.symbol or address[:6] + \"...\" + address[-4:]\n    except Exception:\n        return address[:6] + \"...\" + address[-4:]\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.is_contract","title":"<code>is_contract(address)</code>","text":"<p>Check if address is a contract</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def is_contract(self, address: str) -&gt; bool:\n    \"\"\"Check if address is a contract\"\"\"\n    code = self.web3.eth.get_code(address)\n    return code != b\"\"\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.reset_rpc_failure_counts","title":"<code>reset_rpc_failure_counts()</code>","text":"<p>Reset RPC failure tracking. Call periodically to allow retrying failed RPCs.</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def reset_rpc_failure_counts(self):\n    \"\"\"Reset RPC failure tracking. Call periodically to allow retrying failed RPCs.\"\"\"\n    self._rpc_failure_counts.clear()\n    logger.debug(\"Reset RPC failure counts\")\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.rotate_rpc","title":"<code>rotate_rpc()</code>","text":"<p>Rotate to the next available RPC.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if rotation succeeded, False if no other RPCs available.</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def rotate_rpc(self) -&gt; bool:\n    \"\"\"Rotate to the next available RPC.\n\n    Returns:\n        True if rotation succeeded, False if no other RPCs available.\n\n    \"\"\"\n    if not self.chain.rpcs or len(self.chain.rpcs) &lt;= 1:\n        return False\n\n    original_index = self._current_rpc_index\n    attempts = 0\n\n    while attempts &lt; len(self.chain.rpcs) - 1:\n        self._current_rpc_index = (self._current_rpc_index + 1) % len(self.chain.rpcs)\n        attempts += 1\n\n        # Skip RPCs that have failed too many times recently\n        if self._rpc_failure_counts.get(self._current_rpc_index, 0) &gt;= 5:\n            continue\n\n        logger.info(f\"Rotating RPC for {self.chain.name} to index {self._current_rpc_index}\")\n        self._init_web3()\n\n        # Verify the new RPC works\n        if self.check_rpc_health():\n            return True\n        else:\n            logger.warning(f\"RPC at index {self._current_rpc_index} failed health check\")\n            self._rpc_failure_counts[self._current_rpc_index] = (\n                self._rpc_failure_counts.get(self._current_rpc_index, 0) + 1\n            )\n\n    # All RPCs failed, restore original\n    self._current_rpc_index = original_index\n    self._init_web3()\n    return False\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.send_native_transfer","title":"<code>send_native_transfer(from_address, to_address, value_wei, sign_callback)</code>","text":"<p>Send native currency transaction with retry logic.</p> <p>Automatically retries on transient errors with RPC rotation.</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def send_native_transfer(\n    self,\n    from_address: str,\n    to_address: EthereumAddress,\n    value_wei: int,\n    sign_callback: Callable[[dict], SignedTransaction],\n) -&gt; Tuple[bool, Optional[str]]:\n    \"\"\"Send native currency transaction with retry logic.\n\n    Automatically retries on transient errors with RPC rotation.\n    \"\"\"\n\n    def _do_transfer() -&gt; Tuple[bool, Optional[str]]:\n        tx = {\n            \"from\": from_address,\n            \"to\": to_address,\n            \"value\": value_wei,\n            \"nonce\": self.web3.eth.get_transaction_count(from_address),\n            \"chainId\": self.chain.chain_id,\n        }\n\n        balance_wei = self.get_native_balance_wei(from_address)\n        gas_price = self.web3.eth.gas_price\n        gas_estimate = self.web3.eth.estimate_gas(tx)\n        required_wei = value_wei + (gas_estimate * gas_price)\n\n        if balance_wei &lt; required_wei:\n            logger.error(\n                f\"Insufficient balance. \"\n                f\"Balance: {self.web3.from_wei(balance_wei, 'ether'):.4f} \"\n                f\"{self.chain.native_currency}, \"\n                f\"Required: {self.web3.from_wei(required_wei, 'ether'):.4f} \"\n                f\"{self.chain.native_currency}\"\n            )\n            return False, None\n\n        tx[\"gas\"] = gas_estimate\n        tx[\"gasPrice\"] = gas_price\n\n        signed_tx = sign_callback(tx)\n        txn_hash = self.web3.eth.send_raw_transaction(signed_tx.raw_transaction)\n        receipt = self.web3.eth.wait_for_transaction_receipt(txn_hash)\n\n        # Use status from receipt, handle both object and dict\n        status = getattr(receipt, \"status\", None)\n        if status is None and isinstance(receipt, dict):\n            status = receipt.get(\"status\")\n\n        if receipt and status == 1:\n            self.wait_for_no_pending_tx(from_address)\n            logger.info(f\"Transaction sent successfully. Tx Hash: {txn_hash.hex()}\")\n            return True, receipt[\"transactionHash\"].hex()\n\n        logger.error(\"Transaction failed (status != 1)\")\n        return False, None\n\n    try:\n        return self.with_retry(\n            _do_transfer,\n            operation_name=f\"native_transfer to {str(to_address)[:10]}...\",\n        )\n    except Exception as e:\n        logger.exception(f\"Native transfer failed: {e}\")\n        return False, None\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.wait_for_no_pending_tx","title":"<code>wait_for_no_pending_tx(from_address, max_wait_seconds=60, poll_interval=2.0)</code>","text":"<p>Wait for no pending transactions for a specified time.</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def wait_for_no_pending_tx(\n    self, from_address: str, max_wait_seconds: int = 60, poll_interval: float = 2.0\n):\n    \"\"\"Wait for no pending transactions for a specified time.\"\"\"\n    start_time = time.time()\n    while time.time() - start_time &lt; max_wait_seconds:\n        latest_nonce = self.web3.eth.get_transaction_count(\n            from_address, block_identifier=\"latest\"\n        )\n        pending_nonce = self.web3.eth.get_transaction_count(\n            from_address, block_identifier=\"pending\"\n        )\n\n        if pending_nonce == latest_nonce:\n            return True\n\n        time.sleep(poll_interval)\n\n    return False\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.with_retry","title":"<code>with_retry(operation, max_retries=None, operation_name='operation')</code>","text":"<p>Execute an operation with retry logic.</p> <p>Automatically handles: - Rate limit errors (with exponential backoff) - Connection errors (with RPC rotation) - Server errors (with standard retry)</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>Callable[[], T]</code> <p>Callable that performs the RPC operation.</p> required <code>max_retries</code> <code>Optional[int]</code> <p>Maximum retry attempts (default: DEFAULT_MAX_RETRIES).</p> <code>None</code> <code>operation_name</code> <code>str</code> <p>Name for logging purposes.</p> <code>'operation'</code> <p>Returns:</p> Type Description <code>T</code> <p>The result of the operation.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If all retries are exhausted.</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def with_retry(\n    self,\n    operation: Callable[[], T],\n    max_retries: Optional[int] = None,\n    operation_name: str = \"operation\",\n) -&gt; T:\n    \"\"\"Execute an operation with retry logic.\n\n    Automatically handles:\n    - Rate limit errors (with exponential backoff)\n    - Connection errors (with RPC rotation)\n    - Server errors (with standard retry)\n\n    Args:\n        operation: Callable that performs the RPC operation.\n        max_retries: Maximum retry attempts (default: DEFAULT_MAX_RETRIES).\n        operation_name: Name for logging purposes.\n\n    Returns:\n        The result of the operation.\n\n    Raises:\n        Exception: If all retries are exhausted.\n\n    \"\"\"\n    if max_retries is None:\n        max_retries = self.DEFAULT_MAX_RETRIES\n\n    last_error = None\n\n    for attempt in range(max_retries + 1):\n        try:\n            return operation()\n        except Exception as e:\n            last_error = e\n            result = self._handle_rpc_error(e)\n\n            if not result[\"should_retry\"] or attempt &gt;= max_retries:\n                logger.error(f\"{operation_name} failed after {attempt + 1} attempts: {e}\")\n                raise\n\n            # Exponential backoff\n            delay = self.DEFAULT_RETRY_DELAY * (2**attempt)\n            logger.info(\n                f\"{operation_name} attempt {attempt + 1} failed, retrying in {delay:.1f}s...\"\n            )\n            time.sleep(delay)\n\n    if last_error:\n        raise last_error\n    # Fallback if loop finishes without error (should cover based on logic)\n    raise RuntimeError(f\"{operation_name} failed unexpectedly\")\n</code></pre>"},{"location":"core/#iwa.core.chain.SupportedChain","title":"<code>SupportedChain</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>SupportedChain</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>class SupportedChain(BaseModel):\n    \"\"\"SupportedChain\"\"\"\n\n    name: str\n    rpcs: List[str]\n    chain_id: int\n    native_currency: str\n    tokens: Dict[str, EthereumAddress] = {}\n    contracts: Dict[str, EthereumAddress] = {}\n\n    @property\n    def rpc(self) -&gt; str:\n        \"\"\"Get the primary RPC URL.\n\n        Returns:\n            str: The first RPC URL in the list, or empty string if none.\n\n        \"\"\"\n        return self.rpcs[0] if self.rpcs else \"\"\n\n    def get_token_address(self, token_address_or_name: str) -&gt; Optional[EthereumAddress]:\n        \"\"\"Get token address\"\"\"\n        try:\n            address = EthereumAddress(token_address_or_name)\n        except Exception:\n            address = None\n\n        # If a valid address is provided and it exists in the supported tokens, return it\n        if address and address in self.tokens.values():\n            return address\n\n        # If a token name is provided, return the corresponding address\n        if address is None:\n            return self.tokens.get(token_address_or_name, None)\n\n        return None\n</code></pre>"},{"location":"core/#iwa.core.chain.SupportedChain.rpc","title":"<code>rpc</code>  <code>property</code>","text":"<p>Get the primary RPC URL.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The first RPC URL in the list, or empty string if none.</p>"},{"location":"core/#iwa.core.chain.SupportedChain.get_token_address","title":"<code>get_token_address(token_address_or_name)</code>","text":"<p>Get token address</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def get_token_address(self, token_address_or_name: str) -&gt; Optional[EthereumAddress]:\n    \"\"\"Get token address\"\"\"\n    try:\n        address = EthereumAddress(token_address_or_name)\n    except Exception:\n        address = None\n\n    # If a valid address is provided and it exists in the supported tokens, return it\n    if address and address in self.tokens.values():\n        return address\n\n    # If a token name is provided, return the corresponding address\n    if address is None:\n        return self.tokens.get(token_address_or_name, None)\n\n    return None\n</code></pre>"},{"location":"core/#iwa.core.chain.Gnosis","title":"<code>Gnosis</code>","text":"<p>               Bases: <code>SupportedChain</code></p> <p>Gnosis Chain</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>@singleton\nclass Gnosis(SupportedChain):\n    \"\"\"Gnosis Chain\"\"\"\n\n    name: str = \"Gnosis\"\n    rpcs: List[str] = (\n        settings.gnosis_rpc.get_secret_value().split(\",\") if settings.gnosis_rpc else []\n    )\n    chain_id: int = 100\n    native_currency: str = \"xDAI\"\n    tokens: Dict[str, EthereumAddress] = {\n        \"OLAS\": EthereumAddress(\"0xcE11e14225575945b8E6Dc0D4F2dD4C570f79d9f\"),\n        \"WXDAI\": EthereumAddress(\"0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d\"),\n        \"USDC\": EthereumAddress(\"0x2a22f9c3b484c3629090FeED35F17Ff8F88f76F0\"),\n        \"SDAI\": EthereumAddress(\"0xaf204776c7245bF4147c2612BF6e5972Ee483701\"),\n        \"EURE\": EthereumAddress(\"0x420CA0f9B9b604cE0fd9C18EF134C705e5Fa3430\"),\n    }\n    contracts: Dict[str, EthereumAddress] = {\n        \"GNOSIS_SAFE_MULTISIG_IMPLEMENTATION\": EthereumAddress(\n            \"0x3C1fF68f5aa342D296d4DEe4Bb1cACCA912D95fE\"\n        ),\n        \"GNOSIS_SAFE_FALLBACK_HANDLER\": EthereumAddress(\n            \"0xf48f2b2d2a534e402487b3ee7c18c33aec0fe5e4\"\n        ),\n    }\n</code></pre>"},{"location":"core/#iwa.core.chain.Ethereum","title":"<code>Ethereum</code>","text":"<p>               Bases: <code>SupportedChain</code></p> <p>Ethereum Mainnet</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>@singleton\nclass Ethereum(SupportedChain):\n    \"\"\"Ethereum Mainnet\"\"\"\n\n    name: str = \"Ethereum\"\n    rpcs: List[str] = (\n        settings.ethereum_rpc.get_secret_value().split(\",\") if settings.ethereum_rpc else []\n    )\n    chain_id: int = 1\n    native_currency: str = \"ETH\"\n    tokens: Dict[str, EthereumAddress] = {\n        \"OLAS\": EthereumAddress(\"0x0001A500A6B18995B03f44bb040A5fFc28E45CB0\"),\n    }\n    contracts: Dict[str, EthereumAddress] = {}\n</code></pre>"},{"location":"core/#iwa.core.chain.Base","title":"<code>Base</code>","text":"<p>               Bases: <code>SupportedChain</code></p> <p>Base</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>@singleton\nclass Base(SupportedChain):\n    \"\"\"Base\"\"\"\n\n    name: str = \"Base\"\n    rpcs: List[str] = settings.base_rpc.get_secret_value().split(\",\") if settings.base_rpc else []\n    chain_id: int = 8453\n    native_currency: str = \"ETH\"\n    tokens: Dict[str, EthereumAddress] = {\n        \"OLAS\": EthereumAddress(\"0x54330d28ca3357F294334BDC454a032e7f353416\"),\n    }\n    contracts: Dict[str, EthereumAddress] = {}\n</code></pre>"},{"location":"plugins/","title":"Plugins","text":"<p>This section documents the available plugins in the Iwa framework.</p>"},{"location":"plugins/#gnosis","title":"Gnosis","text":""},{"location":"plugins/#iwa.plugins.gnosis.plugin","title":"<code>iwa.plugins.gnosis.plugin</code>","text":"<p>Gnosis Safe plugin.</p>"},{"location":"plugins/#iwa.plugins.gnosis.plugin.GnosisPlugin","title":"<code>GnosisPlugin</code>","text":"<p>               Bases: <code>Plugin</code></p> <p>Gnosis Safe Plugin.</p> Source code in <code>src/iwa/plugins/gnosis/plugin.py</code> <pre><code>class GnosisPlugin(Plugin):\n    \"\"\"Gnosis Safe Plugin.\"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Get plugin name.\"\"\"\n        return \"gnosis\"\n\n    def get_cli_commands(self) -&gt; Dict[str, callable]:\n        \"\"\"Get CLI commands.\"\"\"\n        return {\"create-safe\": self.create_safe_command}\n\n    def create_safe_command(\n        self,\n        tag: Optional[str] = typer.Option(\n            None,\n            \"--tag\",\n            \"-t\",\n            help=\"Tag for this account\",\n        ),\n        owners: str = typer.Option(\n            ...,\n            \"--owners\",\n            \"-o\",\n            help=\"Comma-separated list of owner addresses or tags.\",\n        ),\n        threshold: int = typer.Option(\n            ...,\n            \"--threshold\",\n            \"-h\",\n            help=\"Number of required confirmations.\",\n        ),\n        chain_name: str = typer.Option(\n            \"gnosis\",\n            \"--chain\",\n            \"-c\",\n            help=\"Chain to deploy the multisig on.\",\n        ),\n    ):\n        \"\"\"Create a new multisig account (Safe)\"\"\"\n        from iwa.core.services import AccountService, SafeService\n\n        key_storage = KeyStorage()\n        account_service = AccountService(key_storage)\n        safe_service = SafeService(key_storage, account_service)\n\n        owner_list = [owner.strip() for owner in owners.split(\",\")]\n        try:\n            safe_service.create_safe(\n                deployer_tag_or_address=\"master\",\n                owner_tags_or_addresses=owner_list,\n                threshold=threshold,\n                chain_name=chain_name,\n                tag=tag,\n            )\n        except ValueError as e:\n            typer.echo(f\"Error: {e}\")\n            raise typer.Exit(code=1) from e\n</code></pre>"},{"location":"plugins/#iwa.plugins.gnosis.plugin.GnosisPlugin.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get plugin name.</p>"},{"location":"plugins/#iwa.plugins.gnosis.plugin.GnosisPlugin.create_safe_command","title":"<code>create_safe_command(tag=typer.Option(None, '--tag', '-t', help='Tag for this account'), owners=typer.Option(..., '--owners', '-o', help='Comma-separated list of owner addresses or tags.'), threshold=typer.Option(..., '--threshold', '-h', help='Number of required confirmations.'), chain_name=typer.Option('gnosis', '--chain', '-c', help='Chain to deploy the multisig on.'))</code>","text":"<p>Create a new multisig account (Safe)</p> Source code in <code>src/iwa/plugins/gnosis/plugin.py</code> <pre><code>def create_safe_command(\n    self,\n    tag: Optional[str] = typer.Option(\n        None,\n        \"--tag\",\n        \"-t\",\n        help=\"Tag for this account\",\n    ),\n    owners: str = typer.Option(\n        ...,\n        \"--owners\",\n        \"-o\",\n        help=\"Comma-separated list of owner addresses or tags.\",\n    ),\n    threshold: int = typer.Option(\n        ...,\n        \"--threshold\",\n        \"-h\",\n        help=\"Number of required confirmations.\",\n    ),\n    chain_name: str = typer.Option(\n        \"gnosis\",\n        \"--chain\",\n        \"-c\",\n        help=\"Chain to deploy the multisig on.\",\n    ),\n):\n    \"\"\"Create a new multisig account (Safe)\"\"\"\n    from iwa.core.services import AccountService, SafeService\n\n    key_storage = KeyStorage()\n    account_service = AccountService(key_storage)\n    safe_service = SafeService(key_storage, account_service)\n\n    owner_list = [owner.strip() for owner in owners.split(\",\")]\n    try:\n        safe_service.create_safe(\n            deployer_tag_or_address=\"master\",\n            owner_tags_or_addresses=owner_list,\n            threshold=threshold,\n            chain_name=chain_name,\n            tag=tag,\n        )\n    except ValueError as e:\n        typer.echo(f\"Error: {e}\")\n        raise typer.Exit(code=1) from e\n</code></pre>"},{"location":"plugins/#iwa.plugins.gnosis.plugin.GnosisPlugin.get_cli_commands","title":"<code>get_cli_commands()</code>","text":"<p>Get CLI commands.</p> Source code in <code>src/iwa/plugins/gnosis/plugin.py</code> <pre><code>def get_cli_commands(self) -&gt; Dict[str, callable]:\n    \"\"\"Get CLI commands.\"\"\"\n    return {\"create-safe\": self.create_safe_command}\n</code></pre>"},{"location":"plugins/#olas","title":"Olas","text":""},{"location":"plugins/#iwa.plugins.olas.plugin","title":"<code>iwa.plugins.olas.plugin</code>","text":"<p>Olas plugin.</p>"},{"location":"plugins/#iwa.plugins.olas.plugin.OlasPlugin","title":"<code>OlasPlugin</code>","text":"<p>               Bases: <code>Plugin</code></p> <p>Olas Plugin.</p> Source code in <code>src/iwa/plugins/olas/plugin.py</code> <pre><code>class OlasPlugin(Plugin):\n    \"\"\"Olas Plugin.\"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Get plugin name.\"\"\"\n        return \"olas\"\n\n    @property\n    def config_model(self) -&gt; Type[BaseModel]:\n        \"\"\"Get config model.\"\"\"\n        return OlasConfig\n\n    def get_cli_commands(self) -&gt; Dict[str, callable]:\n        \"\"\"Get CLI commands.\"\"\"\n        return {\n            \"create\": self.create_service,\n            \"import\": self.import_services,\n        }\n\n    def get_tui_view(self, wallet=None):\n        \"\"\"Get TUI widget for this plugin.\"\"\"\n        from iwa.plugins.olas.tui.olas_view import OlasView\n\n        return OlasView(wallet=wallet)\n\n    def create_service(\n        self,\n        chain_name: str = typer.Option(\"gnosis\", \"--chain\", \"-c\"),\n        owner: Optional[str] = typer.Option(None, \"--owner\", \"-o\"),\n        token: Optional[str] = typer.Option(None, \"--token\"),\n        bond: int = typer.Option(1, \"--bond\", \"-b\"),\n    ):\n        \"\"\"Create a new Olas service\"\"\"\n        wallet = Wallet()\n        manager = ServiceManager(wallet)\n        # Note: Manager logic currently depends on internal config state which might need setup\n        manager.create(chain_name, owner, token, bond)\n\n    def _get_safe_signers(self, safe_address: str, chain_name: str) -&gt; tuple:\n        \"\"\"Query Safe signers on-chain.\n\n        Returns:\n            Tuple of (signers_list, safe_exists):\n            - (list, True) if Safe exists and query succeeds\n            - ([], False) if Safe doesn't exist on-chain\n            - (None, None) if RPC not configured (skip verification)\n\n        \"\"\"\n        try:\n            from safe_eth.eth import EthereumClient\n            from safe_eth.safe import Safe\n\n            from iwa.core.settings import settings\n\n            rpc_secret = getattr(settings, f\"{chain_name}_rpc\", None)\n            if not rpc_secret:\n                return None, None  # Can't verify, skip\n\n            ethereum_client = EthereumClient(rpc_secret.get_secret_value())\n            safe = Safe(safe_address, ethereum_client)\n            owners = safe.retrieve_owners()\n            return owners, True\n        except Exception:\n            # Query failed - Safe likely doesn't exist\n            return [], False\n\n    def import_services(  # noqa: C901\n        self,\n        path: str = typer.Argument(..., help=\"Directory to scan for Olas services\"),\n        dry_run: bool = typer.Option(\n            False, \"--dry-run\", \"-n\", help=\"Show what would be imported without making changes\"\n        ),\n        password: Optional[str] = typer.Option(\n            None, \"--password\", \"-p\", help=\"Password for encrypted keys (will prompt if needed)\"\n        ),\n        yes: bool = typer.Option(\n            False, \"--yes\", \"-y\", help=\"Import all without confirmation prompts\"\n        ),\n    ):\n        \"\"\"Import Olas services and keys from external directories.\n\n        Scans the given path recursively for Olas service directories in supported formats:\n        - .trader_runner (trader_alpha style)\n        - .operate (trader_xi style)\n\n        For each discovered service, imports:\n        - Agent private keys (re-encrypted with your wallet password)\n        - Operator/owner private keys\n        - Safe multisig accounts\n        - Service configuration to config.toml\n        \"\"\"\n        from rich.console import Console\n        from rich.table import Table\n\n        from iwa.plugins.olas.importer import OlasServiceImporter\n\n        console = Console()\n\n        # Scan directory\n        console.print(f\"\\n[bold]Scanning[/bold] {path}...\")\n        importer = OlasServiceImporter()\n        discovered = importer.scan_directory(Path(path))\n\n        if not discovered:\n            console.print(\"[yellow]No Olas services found.[/yellow]\")\n            raise typer.Exit(code=0)\n\n        # Display discovered services\n        console.print(f\"\\n[bold green]Found {len(discovered)} service(s):[/bold green]\\n\")\n\n        for i, service in enumerate(discovered, 1):\n            table = Table(\n                title=f\"Service {i}: {service.service_name or 'Unknown'}\", show_header=False\n            )\n            table.add_column(\"Property\", style=\"cyan\")\n            table.add_column(\"Value\")\n\n            table.add_row(\"Format\", service.format)\n            table.add_row(\"Source\", str(service.source_folder))\n            table.add_row(\"Service ID\", str(service.service_id) if service.service_id else \"N/A\")\n            table.add_row(\"Chain\", service.chain_name)\n\n            # Verify Safe exists on-chain and get signers\n            on_chain_signers = None\n            safe_exists = None\n            if service.safe_address:\n                on_chain_signers, safe_exists = self._get_safe_signers(\n                    service.safe_address, service.chain_name\n                )\n\n                # Display Safe with warning if it doesn't exist\n                if safe_exists is None:\n                    table.add_row(\"Safe\", service.safe_address)\n                elif safe_exists:\n                    table.add_row(\"Safe\", f\"{service.safe_address} [green]\u2713[/green]\")\n                else:\n                    table.add_row(\n                        \"Safe\",\n                        f\"[bold red]\u26a0 {service.safe_address} - DOES NOT EXIST ON-CHAIN![/bold red]\",\n                    )\n            else:\n                table.add_row(\"Safe\", \"N/A\")\n\n            for key in service.keys:\n                status = \"\ud83d\udd12 encrypted\" if key.is_encrypted else \"\ud83d\udd13 plaintext\"\n                key_info = f\"{key.address} {status}\"\n\n                # Check if agent is actually a signer of the Safe\n                if key.role == \"agent\" and service.safe_address:\n                    if safe_exists is None:\n                        # Could not verify (no RPC)\n                        pass  # Keep normal display\n                    elif not safe_exists:\n                        # Safe doesn't exist, so agent can't be a signer\n                        key_info = (\n                            f\"[bold red]\u26a0 {key.address} - NOT A SIGNER OF THE SAFE![/bold red]\"\n                        )\n                    elif on_chain_signers is not None:\n                        is_signer = key.address.lower() in [s.lower() for s in on_chain_signers]\n                        if not is_signer:\n                            key_info = (\n                                f\"[bold red]\u26a0 {key.address} - NOT A SIGNER OF THE SAFE![/bold red]\"\n                            )\n\n                table.add_row(f\"Key ({key.role})\", key_info)\n\n            console.print(table)\n            console.print()\n\n        if dry_run:\n            console.print(\"[yellow]Dry run mode - no changes made.[/yellow]\")\n            raise typer.Exit(code=0)\n\n        # Confirm import\n        if not yes:\n            confirm = typer.confirm(\"Import these services?\")\n            if not confirm:\n                console.print(\"[yellow]Aborted.[/yellow]\")\n                raise typer.Exit(code=0)\n\n        # Check if we need a password for encrypted keys\n        needs_password = any(key.is_encrypted for service in discovered for key in service.keys)\n\n        if needs_password and not password:\n            console.print(\n                \"\\n[yellow]Some keys are encrypted. Please enter the source password.[/yellow]\"\n            )\n            password = typer.prompt(\"Password\", hide_input=True)\n\n        # Import each service\n        total_keys = 0\n        total_safes = 0\n        total_services = 0\n        all_skipped = []\n        all_errors = []\n\n        for service in discovered:\n            console.print(\n                f\"\\n[bold]Importing[/bold] {service.service_name or service.source_folder}...\"\n            )\n            result = importer.import_service(service, password)\n\n            total_keys += len(result.imported_keys)\n            total_safes += len(result.imported_safes)\n            total_services += len(result.imported_services)\n            all_skipped.extend(result.skipped)\n            all_errors.extend(result.errors)\n\n            if result.imported_keys:\n                console.print(\n                    f\"  [green]\u2713[/green] Imported keys: {', '.join(result.imported_keys)}\"\n                )\n            if result.imported_safes:\n                console.print(\n                    f\"  [green]\u2713[/green] Imported safes: {', '.join(result.imported_safes)}\"\n                )\n            if result.imported_services:\n                console.print(\n                    f\"  [green]\u2713[/green] Imported services: {', '.join(result.imported_services)}\"\n                )\n            if result.skipped:\n                for item in result.skipped:\n                    console.print(f\"  [yellow]\u2298[/yellow] Skipped: {item}\")\n            if result.errors:\n                for error in result.errors:\n                    console.print(f\"  [red]\u2717[/red] Error: {error}\")\n\n        # Summary\n        console.print(\"\\n[bold]Summary:[/bold]\")\n        console.print(f\"  Keys imported: {total_keys}\")\n        console.print(f\"  Safes imported: {total_safes}\")\n        console.print(f\"  Services imported: {total_services}\")\n        if all_skipped:\n            console.print(f\"  Skipped: {len(all_skipped)}\")\n        if all_errors:\n            console.print(f\"  [red]Errors: {len(all_errors)}[/red]\")\n            raise typer.Exit(code=1)\n</code></pre>"},{"location":"plugins/#iwa.plugins.olas.plugin.OlasPlugin.config_model","title":"<code>config_model</code>  <code>property</code>","text":"<p>Get config model.</p>"},{"location":"plugins/#iwa.plugins.olas.plugin.OlasPlugin.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get plugin name.</p>"},{"location":"plugins/#iwa.plugins.olas.plugin.OlasPlugin.create_service","title":"<code>create_service(chain_name=typer.Option('gnosis', '--chain', '-c'), owner=typer.Option(None, '--owner', '-o'), token=typer.Option(None, '--token'), bond=typer.Option(1, '--bond', '-b'))</code>","text":"<p>Create a new Olas service</p> Source code in <code>src/iwa/plugins/olas/plugin.py</code> <pre><code>def create_service(\n    self,\n    chain_name: str = typer.Option(\"gnosis\", \"--chain\", \"-c\"),\n    owner: Optional[str] = typer.Option(None, \"--owner\", \"-o\"),\n    token: Optional[str] = typer.Option(None, \"--token\"),\n    bond: int = typer.Option(1, \"--bond\", \"-b\"),\n):\n    \"\"\"Create a new Olas service\"\"\"\n    wallet = Wallet()\n    manager = ServiceManager(wallet)\n    # Note: Manager logic currently depends on internal config state which might need setup\n    manager.create(chain_name, owner, token, bond)\n</code></pre>"},{"location":"plugins/#iwa.plugins.olas.plugin.OlasPlugin.get_cli_commands","title":"<code>get_cli_commands()</code>","text":"<p>Get CLI commands.</p> Source code in <code>src/iwa/plugins/olas/plugin.py</code> <pre><code>def get_cli_commands(self) -&gt; Dict[str, callable]:\n    \"\"\"Get CLI commands.\"\"\"\n    return {\n        \"create\": self.create_service,\n        \"import\": self.import_services,\n    }\n</code></pre>"},{"location":"plugins/#iwa.plugins.olas.plugin.OlasPlugin.get_tui_view","title":"<code>get_tui_view(wallet=None)</code>","text":"<p>Get TUI widget for this plugin.</p> Source code in <code>src/iwa/plugins/olas/plugin.py</code> <pre><code>def get_tui_view(self, wallet=None):\n    \"\"\"Get TUI widget for this plugin.\"\"\"\n    from iwa.plugins.olas.tui.olas_view import OlasView\n\n    return OlasView(wallet=wallet)\n</code></pre>"},{"location":"plugins/#iwa.plugins.olas.plugin.OlasPlugin.import_services","title":"<code>import_services(path=typer.Argument(..., help='Directory to scan for Olas services'), dry_run=typer.Option(False, '--dry-run', '-n', help='Show what would be imported without making changes'), password=typer.Option(None, '--password', '-p', help='Password for encrypted keys (will prompt if needed)'), yes=typer.Option(False, '--yes', '-y', help='Import all without confirmation prompts'))</code>","text":"<p>Import Olas services and keys from external directories.</p> <p>Scans the given path recursively for Olas service directories in supported formats: - .trader_runner (trader_alpha style) - .operate (trader_xi style)</p> <p>For each discovered service, imports: - Agent private keys (re-encrypted with your wallet password) - Operator/owner private keys - Safe multisig accounts - Service configuration to config.toml</p> Source code in <code>src/iwa/plugins/olas/plugin.py</code> <pre><code>def import_services(  # noqa: C901\n    self,\n    path: str = typer.Argument(..., help=\"Directory to scan for Olas services\"),\n    dry_run: bool = typer.Option(\n        False, \"--dry-run\", \"-n\", help=\"Show what would be imported without making changes\"\n    ),\n    password: Optional[str] = typer.Option(\n        None, \"--password\", \"-p\", help=\"Password for encrypted keys (will prompt if needed)\"\n    ),\n    yes: bool = typer.Option(\n        False, \"--yes\", \"-y\", help=\"Import all without confirmation prompts\"\n    ),\n):\n    \"\"\"Import Olas services and keys from external directories.\n\n    Scans the given path recursively for Olas service directories in supported formats:\n    - .trader_runner (trader_alpha style)\n    - .operate (trader_xi style)\n\n    For each discovered service, imports:\n    - Agent private keys (re-encrypted with your wallet password)\n    - Operator/owner private keys\n    - Safe multisig accounts\n    - Service configuration to config.toml\n    \"\"\"\n    from rich.console import Console\n    from rich.table import Table\n\n    from iwa.plugins.olas.importer import OlasServiceImporter\n\n    console = Console()\n\n    # Scan directory\n    console.print(f\"\\n[bold]Scanning[/bold] {path}...\")\n    importer = OlasServiceImporter()\n    discovered = importer.scan_directory(Path(path))\n\n    if not discovered:\n        console.print(\"[yellow]No Olas services found.[/yellow]\")\n        raise typer.Exit(code=0)\n\n    # Display discovered services\n    console.print(f\"\\n[bold green]Found {len(discovered)} service(s):[/bold green]\\n\")\n\n    for i, service in enumerate(discovered, 1):\n        table = Table(\n            title=f\"Service {i}: {service.service_name or 'Unknown'}\", show_header=False\n        )\n        table.add_column(\"Property\", style=\"cyan\")\n        table.add_column(\"Value\")\n\n        table.add_row(\"Format\", service.format)\n        table.add_row(\"Source\", str(service.source_folder))\n        table.add_row(\"Service ID\", str(service.service_id) if service.service_id else \"N/A\")\n        table.add_row(\"Chain\", service.chain_name)\n\n        # Verify Safe exists on-chain and get signers\n        on_chain_signers = None\n        safe_exists = None\n        if service.safe_address:\n            on_chain_signers, safe_exists = self._get_safe_signers(\n                service.safe_address, service.chain_name\n            )\n\n            # Display Safe with warning if it doesn't exist\n            if safe_exists is None:\n                table.add_row(\"Safe\", service.safe_address)\n            elif safe_exists:\n                table.add_row(\"Safe\", f\"{service.safe_address} [green]\u2713[/green]\")\n            else:\n                table.add_row(\n                    \"Safe\",\n                    f\"[bold red]\u26a0 {service.safe_address} - DOES NOT EXIST ON-CHAIN![/bold red]\",\n                )\n        else:\n            table.add_row(\"Safe\", \"N/A\")\n\n        for key in service.keys:\n            status = \"\ud83d\udd12 encrypted\" if key.is_encrypted else \"\ud83d\udd13 plaintext\"\n            key_info = f\"{key.address} {status}\"\n\n            # Check if agent is actually a signer of the Safe\n            if key.role == \"agent\" and service.safe_address:\n                if safe_exists is None:\n                    # Could not verify (no RPC)\n                    pass  # Keep normal display\n                elif not safe_exists:\n                    # Safe doesn't exist, so agent can't be a signer\n                    key_info = (\n                        f\"[bold red]\u26a0 {key.address} - NOT A SIGNER OF THE SAFE![/bold red]\"\n                    )\n                elif on_chain_signers is not None:\n                    is_signer = key.address.lower() in [s.lower() for s in on_chain_signers]\n                    if not is_signer:\n                        key_info = (\n                            f\"[bold red]\u26a0 {key.address} - NOT A SIGNER OF THE SAFE![/bold red]\"\n                        )\n\n            table.add_row(f\"Key ({key.role})\", key_info)\n\n        console.print(table)\n        console.print()\n\n    if dry_run:\n        console.print(\"[yellow]Dry run mode - no changes made.[/yellow]\")\n        raise typer.Exit(code=0)\n\n    # Confirm import\n    if not yes:\n        confirm = typer.confirm(\"Import these services?\")\n        if not confirm:\n            console.print(\"[yellow]Aborted.[/yellow]\")\n            raise typer.Exit(code=0)\n\n    # Check if we need a password for encrypted keys\n    needs_password = any(key.is_encrypted for service in discovered for key in service.keys)\n\n    if needs_password and not password:\n        console.print(\n            \"\\n[yellow]Some keys are encrypted. Please enter the source password.[/yellow]\"\n        )\n        password = typer.prompt(\"Password\", hide_input=True)\n\n    # Import each service\n    total_keys = 0\n    total_safes = 0\n    total_services = 0\n    all_skipped = []\n    all_errors = []\n\n    for service in discovered:\n        console.print(\n            f\"\\n[bold]Importing[/bold] {service.service_name or service.source_folder}...\"\n        )\n        result = importer.import_service(service, password)\n\n        total_keys += len(result.imported_keys)\n        total_safes += len(result.imported_safes)\n        total_services += len(result.imported_services)\n        all_skipped.extend(result.skipped)\n        all_errors.extend(result.errors)\n\n        if result.imported_keys:\n            console.print(\n                f\"  [green]\u2713[/green] Imported keys: {', '.join(result.imported_keys)}\"\n            )\n        if result.imported_safes:\n            console.print(\n                f\"  [green]\u2713[/green] Imported safes: {', '.join(result.imported_safes)}\"\n            )\n        if result.imported_services:\n            console.print(\n                f\"  [green]\u2713[/green] Imported services: {', '.join(result.imported_services)}\"\n            )\n        if result.skipped:\n            for item in result.skipped:\n                console.print(f\"  [yellow]\u2298[/yellow] Skipped: {item}\")\n        if result.errors:\n            for error in result.errors:\n                console.print(f\"  [red]\u2717[/red] Error: {error}\")\n\n    # Summary\n    console.print(\"\\n[bold]Summary:[/bold]\")\n    console.print(f\"  Keys imported: {total_keys}\")\n    console.print(f\"  Safes imported: {total_safes}\")\n    console.print(f\"  Services imported: {total_services}\")\n    if all_skipped:\n        console.print(f\"  Skipped: {len(all_skipped)}\")\n    if all_errors:\n        console.print(f\"  [red]Errors: {len(all_errors)}[/red]\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"security/","title":"Security Concept","text":"<p>This document outlines the security architecture of the Iwa Wallet, explaining how secrets, keys, and access controls are managed.</p>"},{"location":"security/#overview","title":"Overview","text":"<p>Iwa is a self-hosted, local-first wallet management tool. It is designed to be run by a single user or a trusted team on their own infrastructure. No sensitive data is ever sent to external servers controlled by the Iwa developers.</p>"},{"location":"security/#secret-management","title":"Secret Management","text":"<p>Application secrets (such as API keys and RPC URLs) are managed via environment variables, typically loaded from a <code>secrets.env</code> file.</p> <ul> <li>Loading: Secrets are loaded into memory using the <code>Secrets</code> class (powered by Pydantic settings).</li> <li>Storage: The <code>secrets.env</code> file should be secured with appropriate file system permissions (e.g., <code>chmod 600</code>) to prevent unauthorized access by other users on the system.</li> <li>Memory: Once loaded, secrets reside in the application's memory. Debug logs are configured to avoid printing these values, but a memory dump of the running process could reveal them.</li> </ul>"},{"location":"security/#private-key-management","title":"Private Key Management","text":"<p>Private keys are never stored in plain text on the disk.</p> <ul> <li>Keystore: Encrypted private keys are stored in a JSON keystore file (default: <code>accounts.json</code>).</li> <li>Encryption: The keystore uses standard encryption (e.g., AES) derived from a user-provided password.</li> <li>Decryption: Keys are decrypted only in memory and only when needed to sign a transaction.</li> <li>Session: When you launch the TUI or CLI, you provide the password. The keys remain accessible in memory for the duration of the session.</li> </ul>"},{"location":"security/#access-control","title":"Access Control","text":"<p>Iwa does not implement multi-user roles or permissions.</p> <ul> <li>Single User: The user running the <code>iwa</code> process has full access to all configured wallets.</li> <li>Infrastructure Security: Security relies on the security of the host machine (access to the <code>secrets.env</code> and <code>accounts.json</code> files).</li> </ul>"},{"location":"security/#logging","title":"Logging","text":"<p>To prevent accidental leakage of sensitive information:</p> <ul> <li>File Logging: Logs are written to <code>iwa.log</code>.</li> <li>Sanitization: The application is designed to avoid logging private keys or full secret values. However, care should be taken when sharing log files for debugging.</li> <li>TUI: The Terminal User Interface suppresses stderr output to prevent logs from overlapping with the UI, redirecting them to the log file instead.</li> </ul>"},{"location":"security/#external-connections","title":"External Connections","text":"<p>Iwa connects to:</p> <ul> <li>RPC Providers: configured in <code>secrets.env</code> (e.g., Gnosis, Ethereum, Base).</li> <li>Price APIs: e.g., Coingecko (if configured).</li> <li>Etherscan/Gnosisscan: For fetching ABI or contract details.</li> </ul> <p>Ensure you trust your RPC providers, as they can see your read requests (though they cannot sign transactions for you).</p>"}]}