{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentation","text":""},{"location":"#overview","title":"Overview","text":"<p>Iwa is designed to be the foundation for secure python-based crypto agents and applications.</p>"},{"location":"#key-concepts","title":"Key Concepts","text":""},{"location":"#key-management","title":"Key Management","text":"<p>Security is paramount. <code>KeyStorage</code> is the \"vault\". It uses a user-provided password to encrypt private keys at rest. When needed, keys are decrypted only transiently for signing and then cleared. Developer Rule: Never use <code>_get_private_key</code>. Use <code>sign_transaction</code> or <code>sign_message</code>.</p>"},{"location":"#plugins","title":"Plugins","text":"<p>To add a new protocol: 1. Create a directory in <code>src/iwa/plugins/&lt;protocol_name&gt;</code>. 2. Implement a <code>Plugin</code> class inheriting from <code>iwa.core.plugins.Plugin</code> in <code>plugin.py</code>. 3. Define CLI commands in your plugin class. 4. Export the plugin class in <code>__init__.py</code>. The <code>PluginLoader</code> will automatically discover it.</p>"},{"location":"#chains","title":"Chains","text":"<p>Support for new chains can be added in <code>src/iwa/core/chain.py</code> by inheriting from <code>SupportedChain</code>.</p>"},{"location":"#api-reference","title":"API Reference","text":"<p>(Run <code>pydoc</code> or view source for standard docstrings)</p>"},{"location":"cli/","title":"CLI Reference","text":"<p>The Iwa CLI is the primary way to interact with the framework. It is built using <code>typer</code>.</p>"},{"location":"cli/#main-command","title":"Main Command","text":""},{"location":"cli/#iwa.core.cli","title":"<code>iwa.core.cli</code>","text":"<p>CLI</p>"},{"location":"cli/#iwa.core.cli.iwa_cli","title":"<code>iwa_cli = typer.Typer(help='iwa command line interface')</code>  <code>module-attribute</code>","text":""},{"location":"core/","title":"Core Modules This section documents the core components of the Iwa framework.","text":""},{"location":"core/#keystorage","title":"KeyStorage","text":""},{"location":"core/#iwa.core.keys","title":"<code>iwa.core.keys</code>","text":"<p>Wallet management</p>"},{"location":"core/#iwa.core.keys.KeyStorage","title":"<code>KeyStorage</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>KeyStorage</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>class KeyStorage(BaseModel):\n    \"\"\"KeyStorage\"\"\"\n\n    accounts: Dict[EthereumAddress, Union[EncryptedAccount, StoredSafeAccount]] = {}\n    _path: Path = PrivateAttr()  # not stored nor validated\n    _password: str = PrivateAttr()\n\n    def __init__(self, path: Path = Path(WALLET_PATH), password: Optional[str] = None):\n        \"\"\"Initialize key storage.\"\"\"\n        super().__init__()\n        self._path = path\n        self._password = password or Secrets().wallet_password.get_secret_value()\n\n        if os.path.exists(path):\n            try:\n                with open(path, \"r\") as f:\n                    data = json.load(f)\n                    self.accounts = {\n                        k: EncryptedAccount(**v) if \"signers\" not in v else StoredSafeAccount(**v)\n                        for k, v in data.get(\"accounts\", {}).items()\n                    }\n            except json.JSONDecodeError:\n                logger.error(f\"Failed to load wallet from {path}: File is corrupted.\")\n                self.accounts = {}\n        else:\n            self.accounts = {}\n\n    @property\n    def master_account(self) -&gt; EncryptedAccount:\n        \"\"\"Get the master account\"\"\"\n        master_account = self.get_account(\"master\")\n\n        if not master_account:\n            return list(self.accounts.values())[0]\n\n        return master_account\n\n    def save(self):\n        \"\"\"Save\"\"\"\n        # Ensure directory exists\n        self._path.parent.mkdir(parents=True, exist_ok=True)\n\n        with open(self._path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(self.model_dump(), f, indent=4)\n\n        # Enforce read/write only for the owner\n        os.chmod(self._path, 0o600)\n\n    def create_account(self, tag: str) -&gt; EncryptedAccount:\n        \"\"\"Create account\"\"\"\n        tags = [acct.tag for acct in self.accounts.values()]\n        if not tags:\n            tag = \"master\"  # First account is always master\n        if tag in tags:\n            raise ValueError(f\"Tag '{tag}' already exists in wallet.\")\n\n        acct = Account.create()\n\n        encrypted = EncryptedAccount.encrypt_private_key(acct.key.hex(), self._password, tag)\n        self.accounts[acct.address] = encrypted\n        self.save()\n        return encrypted\n\n    # ... (create_safe omitted for brevity, but I should log there too if needed)\n\n    def get_account(self, address_or_tag) -&gt; Optional[Union[Account, StoredSafeAccount]]:\n        \"\"\"Get account\"\"\"\n        try:\n            address = EthereumAddress(address_or_tag)\n            account = self.accounts.get(address)\n\n            if isinstance(account, StoredSafeAccount):\n                return account\n\n            if account is None:\n                return None\n\n            if account is None:\n                return None\n\n            # WARNING: This returns an Account object which contains the private key in memory.\n            # Prefer using sign_transaction instead.\n            return Account.from_key(self._get_private_key(address))\n\n        except ValueError:\n            for account in self.accounts.values():\n                if address_or_tag == account.tag:\n                    if isinstance(account, StoredSafeAccount):\n                        return account\n\n                    return Account.from_key(self._get_private_key(account.address))\n            return None\n\n    def create_safe(\n        self,\n        deployer_tag_or_address: str,\n        owner_tags_or_addresses: List[str],\n        threshold: int,\n        chain_name: str,\n        tag: Optional[str] = None,\n    ) -&gt; StoredSafeAccount:\n        \"\"\"Add a Safe to the KeyStorage\"\"\"\n        deployer_account = self.get_account(deployer_tag_or_address)\n        if not deployer_account:\n            raise ValueError(f\"Deployer account '{deployer_tag_or_address}' not found in wallet.\")\n\n        owner_addresses = []\n        for tag_or_address in owner_tags_or_addresses:\n            owner_account = self.get_account(tag_or_address)\n            if not owner_account:\n                raise ValueError(f\"Owner account '{tag_or_address}' not found in wallet.\")\n            owner_addresses.append(owner_account.address)\n\n        rpc_secret = getattr(Secrets(), f\"{chain_name}_rpc\")\n\n        create_tx = Safe.create(\n            ethereum_client=EthereumClient(rpc_secret.get_secret_value()),\n            deployer_account=deployer_account,\n            master_copy_address=get_safe_master_copy_address(\"1.4.1\"),\n            owners=owner_addresses,\n            threshold=threshold,\n        )\n\n        tx_hash = create_tx.tx_hash.hex()\n        logger.info(\n            f\"Safe {tag} [{create_tx.contract_address}] deployed on {chain_name} on transaction: {tx_hash}\"\n        )\n\n        safe_account = StoredSafeAccount(\n            address=create_tx.contract_address,\n            tag=tag,\n            signers=owner_addresses,\n            threshold=threshold,\n            chains=[chain_name],\n        )\n        self.accounts[safe_account.address] = safe_account\n        self.save()\n        return safe_account\n\n    def redeploy_safes(self):\n        \"\"\"Redeploy all safes to ensure they exist on all chains\"\"\"\n        for account in self.accounts.copy().values():\n            if not isinstance(account, StoredSafeAccount):\n                continue\n\n            for chain in account.chains:\n                rpc_secret = getattr(Secrets(), f\"{chain}_rpc\")\n                ethereum_client = EthereumClient(rpc_secret.get_secret_value())\n\n                code = ethereum_client.w3.eth.get_code(account.address)\n\n                if code and code != b\"\":\n                    continue\n\n                self.remove_account(account.address)\n\n                self.create_safe(\n                    deployer_tag_or_address=\"master\",\n                    owner_tags_or_addresses=account.signers,\n                    threshold=account.threshold,\n                    chain_name=chain,\n                    tag=account.tag,\n                )\n\n    def remove_account(self, address: str) -&gt; None:\n        \"\"\"Remove account\"\"\"\n        if address not in self.accounts:\n            return\n        del self.accounts[address]\n\n    def _get_private_key(self, address: str) -&gt; Optional[str]:\n        \"\"\"Internal method to get private key. Do not use outside of this class.\"\"\"\n        if address not in self.accounts:\n            return None\n\n        account = self.accounts[address]\n\n        if isinstance(account, StoredSafeAccount):\n            raise ValueError(\"Cannot get private key for StoredSafeAccount.\")\n\n        return account.decrypt_private_key(self._password)\n\n    def get_private_key_unsafe(self, address: str) -&gt; Optional[str]:\n        \"\"\"\n        Get private key. WARNING: This exposes the private key.\n        Only use when absolutely necessary (e.g. CowSwap SDK).\n        \"\"\"\n        logger.warning(f\"Exposing private key for {address} via unsafe method!\")\n        return self._get_private_key(address)\n\n    def sign_transaction(self, transaction: dict, address_or_tag: str) -&gt; SignedTransaction:\n        \"\"\"Sign a transaction without exposing the private key.\"\"\"\n        account = self.get_account(address_or_tag)\n        if not account:\n            raise ValueError(f\"Account '{address_or_tag}' not found.\")\n\n        address = account.address\n        private_key = self._get_private_key(address)\n        if not private_key:\n             raise ValueError(f\"Could not retrieve private key for {address}\")\n\n        # Account.sign_transaction handles the signing\n        try:\n            return Account.sign_transaction(transaction, private_key)\n        finally:\n            # Best effort to clear variable, though Python's GC is non-deterministic\n            del private_key\n\n    def sign_message(self, message: Union[str, bytes], address_or_tag: str) -&gt; SignedTransaction:\n         \"\"\"Sign a message.\"\"\"\n         account = self.get_account(address_or_tag)\n         if not account:\n             raise ValueError(f\"Account '{address_or_tag}' not found.\")\n\n         address = account.address\n         private_key = self._get_private_key(address)\n\n         if isinstance(message, str):\n             signable_message = encode_defunct(text=message)\n         else:\n             signable_message = encode_defunct(primitive=message)\n\n         try:\n             return Account.sign_message(signable_message, private_key)\n         finally:\n             del private_key\n\n    def get_safe_signer_keys(self, safe_address_or_tag: str) -&gt; List[str]:\n        \"\"\"Get all signer private keys for a safe\"\"\"\n        safe_account = self.get_account(safe_address_or_tag)\n        if not safe_account:\n            raise ValueError(f\"Safe account '{safe_address_or_tag}' not found in wallet.\")\n\n        signer_pkeys = []\n        for signer_address in safe_account.signers:\n            pkey = self._get_private_key(signer_address)\n            if pkey:\n                signer_pkeys.append(pkey)\n\n        if len(signer_pkeys) &lt; safe_account.threshold:\n            raise ValueError(\n                \"Not enough signer private keys in wallet to meet the Safe's threshold.\"\n            )\n\n        return signer_pkeys\n\n\n\n    def get_tag_by_address(self, address: EthereumAddress) -&gt; Optional[str]:\n        \"\"\"Get tag by address\"\"\"\n        account = self.accounts.get(EthereumAddress(address))\n        if account:\n            return account.tag\n        return None\n\n    def get_address_by_tag(self, tag: str) -&gt; Optional[EthereumAddress]:\n        \"\"\"Get address by tag\"\"\"\n        for account in self.accounts.values():\n            if account.tag == tag:\n                return EthereumAddress(account.address)\n        return None\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.master_account","title":"<code>master_account</code>  <code>property</code>","text":"<p>Get the master account</p>"},{"location":"core/#iwa.core.keys.KeyStorage.__init__","title":"<code>__init__(path=Path(WALLET_PATH), password=None)</code>","text":"<p>Initialize key storage.</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def __init__(self, path: Path = Path(WALLET_PATH), password: Optional[str] = None):\n    \"\"\"Initialize key storage.\"\"\"\n    super().__init__()\n    self._path = path\n    self._password = password or Secrets().wallet_password.get_secret_value()\n\n    if os.path.exists(path):\n        try:\n            with open(path, \"r\") as f:\n                data = json.load(f)\n                self.accounts = {\n                    k: EncryptedAccount(**v) if \"signers\" not in v else StoredSafeAccount(**v)\n                    for k, v in data.get(\"accounts\", {}).items()\n                }\n        except json.JSONDecodeError:\n            logger.error(f\"Failed to load wallet from {path}: File is corrupted.\")\n            self.accounts = {}\n    else:\n        self.accounts = {}\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.create_account","title":"<code>create_account(tag)</code>","text":"<p>Create account</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def create_account(self, tag: str) -&gt; EncryptedAccount:\n    \"\"\"Create account\"\"\"\n    tags = [acct.tag for acct in self.accounts.values()]\n    if not tags:\n        tag = \"master\"  # First account is always master\n    if tag in tags:\n        raise ValueError(f\"Tag '{tag}' already exists in wallet.\")\n\n    acct = Account.create()\n\n    encrypted = EncryptedAccount.encrypt_private_key(acct.key.hex(), self._password, tag)\n    self.accounts[acct.address] = encrypted\n    self.save()\n    return encrypted\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.create_safe","title":"<code>create_safe(deployer_tag_or_address, owner_tags_or_addresses, threshold, chain_name, tag=None)</code>","text":"<p>Add a Safe to the KeyStorage</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def create_safe(\n    self,\n    deployer_tag_or_address: str,\n    owner_tags_or_addresses: List[str],\n    threshold: int,\n    chain_name: str,\n    tag: Optional[str] = None,\n) -&gt; StoredSafeAccount:\n    \"\"\"Add a Safe to the KeyStorage\"\"\"\n    deployer_account = self.get_account(deployer_tag_or_address)\n    if not deployer_account:\n        raise ValueError(f\"Deployer account '{deployer_tag_or_address}' not found in wallet.\")\n\n    owner_addresses = []\n    for tag_or_address in owner_tags_or_addresses:\n        owner_account = self.get_account(tag_or_address)\n        if not owner_account:\n            raise ValueError(f\"Owner account '{tag_or_address}' not found in wallet.\")\n        owner_addresses.append(owner_account.address)\n\n    rpc_secret = getattr(Secrets(), f\"{chain_name}_rpc\")\n\n    create_tx = Safe.create(\n        ethereum_client=EthereumClient(rpc_secret.get_secret_value()),\n        deployer_account=deployer_account,\n        master_copy_address=get_safe_master_copy_address(\"1.4.1\"),\n        owners=owner_addresses,\n        threshold=threshold,\n    )\n\n    tx_hash = create_tx.tx_hash.hex()\n    logger.info(\n        f\"Safe {tag} [{create_tx.contract_address}] deployed on {chain_name} on transaction: {tx_hash}\"\n    )\n\n    safe_account = StoredSafeAccount(\n        address=create_tx.contract_address,\n        tag=tag,\n        signers=owner_addresses,\n        threshold=threshold,\n        chains=[chain_name],\n    )\n    self.accounts[safe_account.address] = safe_account\n    self.save()\n    return safe_account\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.get_account","title":"<code>get_account(address_or_tag)</code>","text":"<p>Get account</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def get_account(self, address_or_tag) -&gt; Optional[Union[Account, StoredSafeAccount]]:\n    \"\"\"Get account\"\"\"\n    try:\n        address = EthereumAddress(address_or_tag)\n        account = self.accounts.get(address)\n\n        if isinstance(account, StoredSafeAccount):\n            return account\n\n        if account is None:\n            return None\n\n        if account is None:\n            return None\n\n        # WARNING: This returns an Account object which contains the private key in memory.\n        # Prefer using sign_transaction instead.\n        return Account.from_key(self._get_private_key(address))\n\n    except ValueError:\n        for account in self.accounts.values():\n            if address_or_tag == account.tag:\n                if isinstance(account, StoredSafeAccount):\n                    return account\n\n                return Account.from_key(self._get_private_key(account.address))\n        return None\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.get_address_by_tag","title":"<code>get_address_by_tag(tag)</code>","text":"<p>Get address by tag</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def get_address_by_tag(self, tag: str) -&gt; Optional[EthereumAddress]:\n    \"\"\"Get address by tag\"\"\"\n    for account in self.accounts.values():\n        if account.tag == tag:\n            return EthereumAddress(account.address)\n    return None\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.get_private_key_unsafe","title":"<code>get_private_key_unsafe(address)</code>","text":"<p>Get private key. WARNING: This exposes the private key. Only use when absolutely necessary (e.g. CowSwap SDK).</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def get_private_key_unsafe(self, address: str) -&gt; Optional[str]:\n    \"\"\"\n    Get private key. WARNING: This exposes the private key.\n    Only use when absolutely necessary (e.g. CowSwap SDK).\n    \"\"\"\n    logger.warning(f\"Exposing private key for {address} via unsafe method!\")\n    return self._get_private_key(address)\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.get_safe_signer_keys","title":"<code>get_safe_signer_keys(safe_address_or_tag)</code>","text":"<p>Get all signer private keys for a safe</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def get_safe_signer_keys(self, safe_address_or_tag: str) -&gt; List[str]:\n    \"\"\"Get all signer private keys for a safe\"\"\"\n    safe_account = self.get_account(safe_address_or_tag)\n    if not safe_account:\n        raise ValueError(f\"Safe account '{safe_address_or_tag}' not found in wallet.\")\n\n    signer_pkeys = []\n    for signer_address in safe_account.signers:\n        pkey = self._get_private_key(signer_address)\n        if pkey:\n            signer_pkeys.append(pkey)\n\n    if len(signer_pkeys) &lt; safe_account.threshold:\n        raise ValueError(\n            \"Not enough signer private keys in wallet to meet the Safe's threshold.\"\n        )\n\n    return signer_pkeys\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.get_tag_by_address","title":"<code>get_tag_by_address(address)</code>","text":"<p>Get tag by address</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def get_tag_by_address(self, address: EthereumAddress) -&gt; Optional[str]:\n    \"\"\"Get tag by address\"\"\"\n    account = self.accounts.get(EthereumAddress(address))\n    if account:\n        return account.tag\n    return None\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.redeploy_safes","title":"<code>redeploy_safes()</code>","text":"<p>Redeploy all safes to ensure they exist on all chains</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def redeploy_safes(self):\n    \"\"\"Redeploy all safes to ensure they exist on all chains\"\"\"\n    for account in self.accounts.copy().values():\n        if not isinstance(account, StoredSafeAccount):\n            continue\n\n        for chain in account.chains:\n            rpc_secret = getattr(Secrets(), f\"{chain}_rpc\")\n            ethereum_client = EthereumClient(rpc_secret.get_secret_value())\n\n            code = ethereum_client.w3.eth.get_code(account.address)\n\n            if code and code != b\"\":\n                continue\n\n            self.remove_account(account.address)\n\n            self.create_safe(\n                deployer_tag_or_address=\"master\",\n                owner_tags_or_addresses=account.signers,\n                threshold=account.threshold,\n                chain_name=chain,\n                tag=account.tag,\n            )\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.remove_account","title":"<code>remove_account(address)</code>","text":"<p>Remove account</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def remove_account(self, address: str) -&gt; None:\n    \"\"\"Remove account\"\"\"\n    if address not in self.accounts:\n        return\n    del self.accounts[address]\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.save","title":"<code>save()</code>","text":"<p>Save</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def save(self):\n    \"\"\"Save\"\"\"\n    # Ensure directory exists\n    self._path.parent.mkdir(parents=True, exist_ok=True)\n\n    with open(self._path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(self.model_dump(), f, indent=4)\n\n    # Enforce read/write only for the owner\n    os.chmod(self._path, 0o600)\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.sign_message","title":"<code>sign_message(message, address_or_tag)</code>","text":"<p>Sign a message.</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def sign_message(self, message: Union[str, bytes], address_or_tag: str) -&gt; SignedTransaction:\n     \"\"\"Sign a message.\"\"\"\n     account = self.get_account(address_or_tag)\n     if not account:\n         raise ValueError(f\"Account '{address_or_tag}' not found.\")\n\n     address = account.address\n     private_key = self._get_private_key(address)\n\n     if isinstance(message, str):\n         signable_message = encode_defunct(text=message)\n     else:\n         signable_message = encode_defunct(primitive=message)\n\n     try:\n         return Account.sign_message(signable_message, private_key)\n     finally:\n         del private_key\n</code></pre>"},{"location":"core/#iwa.core.keys.KeyStorage.sign_transaction","title":"<code>sign_transaction(transaction, address_or_tag)</code>","text":"<p>Sign a transaction without exposing the private key.</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def sign_transaction(self, transaction: dict, address_or_tag: str) -&gt; SignedTransaction:\n    \"\"\"Sign a transaction without exposing the private key.\"\"\"\n    account = self.get_account(address_or_tag)\n    if not account:\n        raise ValueError(f\"Account '{address_or_tag}' not found.\")\n\n    address = account.address\n    private_key = self._get_private_key(address)\n    if not private_key:\n         raise ValueError(f\"Could not retrieve private key for {address}\")\n\n    # Account.sign_transaction handles the signing\n    try:\n        return Account.sign_transaction(transaction, private_key)\n    finally:\n        # Best effort to clear variable, though Python's GC is non-deterministic\n        del private_key\n</code></pre>"},{"location":"core/#iwa.core.keys.EncryptedAccount","title":"<code>EncryptedAccount</code>","text":"<p>               Bases: <code>StoredAccount</code></p> <p>EncryptedAccount</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>class EncryptedAccount(StoredAccount):\n    \"\"\"EncryptedAccount\"\"\"\n\n    salt: str\n    nonce: str\n    ciphertext: str\n\n    @staticmethod\n    def derive_key(password: str, salt: bytes) -&gt; bytes:\n        \"\"\"Derive key\"\"\"\n        kdf = Scrypt(\n            salt=salt,\n            length=32,\n            n=2**14,\n            r=8,\n            p=1,\n        )\n        return kdf.derive(password.encode())\n\n    def decrypt_private_key(self, password: Optional[str] = None) -&gt; str:\n        \"\"\"decrypt_private_key\"\"\"\n        password = password or Secrets().wallet_password.get_secret_value()\n        salt_bytes = base64.b64decode(self.salt)\n        nonce_bytes = base64.b64decode(self.nonce)\n        ciphertext_bytes = base64.b64decode(self.ciphertext)\n        key = EncryptedAccount.derive_key(password, salt_bytes)\n        aesgcm = AESGCM(key)\n        return aesgcm.decrypt(nonce_bytes, ciphertext_bytes, None).decode()\n\n    @staticmethod\n    def encrypt_private_key(\n        private_key: str, password: str, tag: Optional[str] = None\n    ) -&gt; \"EncryptedAccount\":\n        \"\"\"Encrypt private key\"\"\"\n        salt = os.urandom(16)\n        key = EncryptedAccount.derive_key(password, salt)\n        aesgcm = AESGCM(key)\n        nonce = os.urandom(12)\n        ciphertext = aesgcm.encrypt(nonce, private_key.encode(), None)\n\n        acct = Account.from_key(private_key)\n        return EncryptedAccount(\n            address=acct.address,\n            salt=base64.b64encode(salt).decode(),\n            nonce=base64.b64encode(nonce).decode(),\n            ciphertext=base64.b64encode(ciphertext).decode(),\n            tag=tag,\n        )\n</code></pre>"},{"location":"core/#iwa.core.keys.EncryptedAccount.decrypt_private_key","title":"<code>decrypt_private_key(password=None)</code>","text":"<p>decrypt_private_key</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>def decrypt_private_key(self, password: Optional[str] = None) -&gt; str:\n    \"\"\"decrypt_private_key\"\"\"\n    password = password or Secrets().wallet_password.get_secret_value()\n    salt_bytes = base64.b64decode(self.salt)\n    nonce_bytes = base64.b64decode(self.nonce)\n    ciphertext_bytes = base64.b64decode(self.ciphertext)\n    key = EncryptedAccount.derive_key(password, salt_bytes)\n    aesgcm = AESGCM(key)\n    return aesgcm.decrypt(nonce_bytes, ciphertext_bytes, None).decode()\n</code></pre>"},{"location":"core/#iwa.core.keys.EncryptedAccount.derive_key","title":"<code>derive_key(password, salt)</code>  <code>staticmethod</code>","text":"<p>Derive key</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>@staticmethod\ndef derive_key(password: str, salt: bytes) -&gt; bytes:\n    \"\"\"Derive key\"\"\"\n    kdf = Scrypt(\n        salt=salt,\n        length=32,\n        n=2**14,\n        r=8,\n        p=1,\n    )\n    return kdf.derive(password.encode())\n</code></pre>"},{"location":"core/#iwa.core.keys.EncryptedAccount.encrypt_private_key","title":"<code>encrypt_private_key(private_key, password, tag=None)</code>  <code>staticmethod</code>","text":"<p>Encrypt private key</p> Source code in <code>src/iwa/core/keys.py</code> <pre><code>@staticmethod\ndef encrypt_private_key(\n    private_key: str, password: str, tag: Optional[str] = None\n) -&gt; \"EncryptedAccount\":\n    \"\"\"Encrypt private key\"\"\"\n    salt = os.urandom(16)\n    key = EncryptedAccount.derive_key(password, salt)\n    aesgcm = AESGCM(key)\n    nonce = os.urandom(12)\n    ciphertext = aesgcm.encrypt(nonce, private_key.encode(), None)\n\n    acct = Account.from_key(private_key)\n    return EncryptedAccount(\n        address=acct.address,\n        salt=base64.b64encode(salt).decode(),\n        nonce=base64.b64encode(nonce).decode(),\n        ciphertext=base64.b64encode(ciphertext).decode(),\n        tag=tag,\n    )\n</code></pre>"},{"location":"core/#iwa.core.keys.StoredSafeAccount","title":"<code>StoredSafeAccount</code>","text":"<p>               Bases: <code>StoredAccount</code></p> <p>StoredSafeAccount</p> Source code in <code>src/iwa/core/models.py</code> <pre><code>class StoredSafeAccount(StoredAccount):\n    \"\"\"StoredSafeAccount\"\"\"\n\n    signers: List[EthereumAddress]\n    threshold: int\n    chains: List[str]\n</code></pre>"},{"location":"core/#wallet","title":"Wallet","text":""},{"location":"core/#iwa.core.wallet","title":"<code>iwa.core.wallet</code>","text":"<p>Wallet module.</p>"},{"location":"core/#iwa.core.wallet.Wallet","title":"<code>Wallet</code>","text":"<p>Wallet management</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>class Wallet:\n    \"\"\"Wallet management\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize wallet.\"\"\"\n        self.key_storage = KeyStorage()\n        self.transaction_manager = TransactionManager(self.key_storage)\n\n    @property\n    def master_account(self) -&gt; Optional[StoredSafeAccount]:\n        \"\"\"Get master account\"\"\"\n        return self.key_storage.master_account\n\n    def get_token_address(\n        self, token_address_or_name: str, chain: SupportedChain\n    ) -&gt; Optional[EthereumAddress]:\n        \"\"\"Get token address from address or name\"\"\"\n        if token_address_or_name == \"native\":\n            return EthereumAddress(NATIVE_CURRENCY_ADDRESS)\n\n        try:\n            token_address = EthereumAddress(token_address_or_name)\n            return token_address\n        except ValueError:\n            token_address = chain.get_token_address(token_address_or_name)\n            if not token_address:\n                logger.error(f\"Token '{token_address_or_name}' not found on chain '{chain.name}'.\")\n                return None\n            return token_address\n\n    def list_accounts(self, chain_name: str, balances: Optional[str] = None) -&gt; None:\n        \"\"\"List accounts\"\"\"\n        chain_interface = ChainInterfaces().get(chain_name)\n        token_names = balances.split(\",\") if balances else []\n\n        token_balances = (\n            {\n                account_address: {\n                    token_name: self.get_erc20_balance_eth(account_address, token_name)\n                    if token_name != \"native\"\n                    else chain_interface.get_native_balance_eth(account_address)\n                    for token_name in token_names\n                }\n                for account_address in self.key_storage.accounts.keys()\n            }\n            if token_names\n            else None\n        )\n\n        list_accounts(self.key_storage.accounts, chain_interface, token_names, token_balances)\n\n    def sign_and_send_transaction(\n        self, transaction: dict, signer_address_or_tag: str, chain_name: str = \"gnosis\"\n    ) -&gt; Tuple[bool, Dict]:\n        \"\"\"Sign and send transaction\"\"\"\n        return self.transaction_manager.sign_and_send(\n            transaction, signer_address_or_tag, chain_name\n        )\n\n    def send(\n        self,\n        from_address_or_tag: str,\n        to_address_or_tag: str,\n        token_address_or_name: str,\n        amount_wei: int,\n        chain_name: str = \"gnosis\",\n    ):\n        \"\"\"Send native currency or ERC20 tokens to an address\"\"\"\n        from_account = self.key_storage.get_account(from_address_or_tag)\n        to_account = self.key_storage.get_account(to_address_or_tag)\n        to_address = to_account.address if to_account else to_address_or_tag\n\n        if not from_account:\n            logger.error(f\"From account '{from_address_or_tag}' not found in wallet.\")\n            return\n\n        chain_interface = ChainInterfaces().get(chain_name)\n\n        token_address = self.get_token_address(token_address_or_name, chain_interface.chain)\n        if not token_address:\n            return\n\n        is_safe = isinstance(from_account, StoredSafeAccount)\n\n        if token_address == NATIVE_CURRENCY_ADDRESS:\n            logger.info(\n                f\"Sending {chain_interface.web3.from_wei(amount_wei, 'ether'):.4f} {chain_interface.chain.native_currency} from {from_address_or_tag} to {to_address_or_tag}\"\n            )\n            if is_safe:\n                safe = SafeMultisig(from_account, chain_name)\n                safe.send_tx(\n                    to=to_address,\n                    value=amount_wei,\n                    signers_private_keys=self.key_storage.get_safe_signer_keys(from_address_or_tag),\n                )\n\n            else:\n                chain_interface.send_native_transfer(\n                    from_account=from_account,\n                    to_address=to_address,\n                    value_wei=amount_wei,\n                )\n            return\n\n        erc20 = ERC20Contract(token_address)\n        transaction = erc20.prepare_transfer_tx(\n            from_account.address,\n            to_address,\n            amount_wei,\n        )\n        if not transaction:\n            return\n\n        amount_eth = chain_interface.web3.from_wei(amount_wei, \"ether\")\n        logger.info(\n            f\"Sending {amount_eth:.4f} {token_address_or_name} from {from_address_or_tag} to {to_address_or_tag}\"\n        )\n\n        if is_safe:\n            safe = SafeMultisig(from_account, chain_name)\n            safe.send_tx(\n                to=erc20.address,\n                value=0,\n                signers_private_keys=self.key_storage.get_safe_signer_keys(from_address_or_tag),\n                data=transaction[\"data\"],\n            )\n        else:\n            self.sign_and_send_transaction(transaction, from_address_or_tag, chain_name)\n\n    def multi_send(\n        self,\n        from_address_or_tag: str,\n        transactions: list,\n        chain_name: str = \"gnosis\",\n    ):\n        \"\"\"Send multiple transactions in a single multisend transaction\"\"\"\n        from_account = self.key_storage.get_account(from_address_or_tag)\n        is_safe = isinstance(from_account, StoredSafeAccount)\n\n        if not from_account:\n            logger.error(f\"From account '{from_address_or_tag}' not found in wallet.\")\n            return\n\n        chain_interface = ChainInterfaces().get(chain_name)\n\n        is_all_native = all(\n            tx.get(\"token\", NATIVE_CURRENCY_ADDRESS) == NATIVE_CURRENCY_ADDRESS\n            for tx in transactions\n        )\n\n        if not is_safe and not is_all_native:\n            raise ValueError(\"Multisend with ERC20 tokens requires a Safe account.\")\n\n        for tx in transactions:\n            to = self.key_storage.get_account(tx[\"to\"])\n            recipient_address = to.address if to else tx[\"to\"]\n            amount_wei = chain_interface.web3.to_wei(tx[\"amount\"], \"ether\")\n            token_address_or_tag = tx.get(\"token\", NATIVE_CURRENCY_ADDRESS)\n            if \"amount\" in tx:\n                del tx[\"amount\"]\n            if \"token\" in tx:\n                del tx[\"token\"]\n\n            if token_address_or_tag == NATIVE_CURRENCY_ADDRESS:\n                tx[\"to\"] = recipient_address\n                tx[\"value\"] = amount_wei\n                tx[\"data\"] = b\"\"\n                tx[\"operation\"] = SafeOperationEnum.CALL\n\n            else:\n                token_address = self.get_token_address(token_address_or_tag, chain_interface.chain)\n                erc20 = ERC20Contract(token_address, chain_name)\n                transfer_tx = erc20.prepare_transfer_tx(\n                    from_address=from_account.address,\n                    to=recipient_address,\n                    amount_wei=amount_wei,\n                )\n                tx[\"to\"] = erc20.address\n                tx[\"value\"] = 0\n                tx[\"data\"] = transfer_tx[\"data\"]\n                tx[\"operation\"] = SafeOperationEnum.CALL\n\n        multi_send_normal_contract = MultiSendContract(\n            address=MULTISEND_ADDRESS_GNOSIS, chain_name=chain_name\n        )\n        multi_send_call_only_contract = MultiSendCallOnlyContract(\n            address=MULTISEND_CALL_ONLY_ADDRESS_GNOSIS, chain_name=chain_name\n        )\n\n        multi_send_contract = (\n            multi_send_normal_contract if is_safe else multi_send_call_only_contract\n        )\n        transaction = multi_send_contract.prepare_tx(\n            from_address=from_account.address, transactions=transactions\n        )\n        if not transaction:\n            return\n\n        logger.info(\"Sending multisend transaction\")\n\n        if is_safe:\n            safe = SafeMultisig(from_account, chain_name)\n            safe.send_tx(\n                to=multi_send_contract.address,\n                value=transaction[\"value\"],\n                signers_private_keys=self.key_storage.get_safe_signer_keys(from_address_or_tag),\n                data=transaction[\"data\"],\n                operation=SafeOperationEnum.DELEGATE_CALL.value,\n            )\n        else:\n            self.sign_and_send_transaction(transaction, from_address_or_tag, chain_name)\n\n    def get_native_balance_eth(\n        self, account_address: str, chain_name: str = \"gnosis\"\n    ) -&gt; Optional[float]:\n        \"\"\"Get native currency balance\"\"\"\n        chain_interface = ChainInterfaces().get(chain_name)\n        return chain_interface.get_native_balance_eth(account_address)\n\n    def get_native_balance_wei(\n        self, account_address: str, chain_name: str = \"gnosis\"\n    ) -&gt; Optional[int]:\n        \"\"\"Get native currency balance\"\"\"\n        chain_interface = ChainInterfaces().get(chain_name)\n        return chain_interface.get_native_balance_wei(account_address)\n\n    def get_erc20_balance_eth(\n        self, account_address_or_tag: str, token_address_or_name: str, chain_name: str = \"gnosis\"\n    ) -&gt; Optional[float]:\n        \"\"\"Get ERC20 token balance\"\"\"\n        chain = ChainInterfaces().get(chain_name)\n\n        token_address = self.get_token_address(token_address_or_name, chain.chain)\n        if not token_address:\n            return None\n\n        account = self.key_storage.get_account(account_address_or_tag)\n        if not account:\n            return None\n\n        contract = ERC20Contract(chain_name=chain_name, address=token_address)\n        return contract.balance_of_eth(account.address)\n\n    def get_erc20_balance_wei(\n        self, account_address_or_tag: str, token_address_or_name: str, chain_name: str = \"gnosis\"\n    ) -&gt; Optional[int]:\n        \"\"\"Get ERC20 token balance\"\"\"\n        chain = ChainInterfaces().get(chain_name)\n\n        token_address = self.get_token_address(token_address_or_name, chain.chain)\n        if not token_address:\n            return None\n\n        account = self.key_storage.get_account(account_address_or_tag)\n        if not account:\n            return None\n\n        contract = ERC20Contract(chain_name=chain_name, address=token_address)\n        return contract.balance_of_wei(account.address)\n\n    def get_erc20_allowance(\n        self,\n        owner_address_or_tag: str,\n        spender_address: str,\n        token_address_or_name: str,\n        chain_name: str = \"gnosis\",\n    ) -&gt; Optional[float]:\n        \"\"\"Get ERC20 token allowance\"\"\"\n        chain = ChainInterfaces().get(chain_name)\n\n        token_address = self.get_token_address(token_address_or_name, chain.chain)\n        if not token_address:\n            return None\n\n        owner_account = self.key_storage.get_account(owner_address_or_tag)\n        if not owner_account:\n            return None\n\n        contract = ERC20Contract(chain_name=chain_name, address=token_address)\n        return contract.allowance_wei(owner_account.address, spender_address)\n\n    def approve_erc20(\n        self,\n        owner_address_or_tag: str,\n        spender_address_or_tag: str,\n        token_address_or_name: str,\n        amount_wei: int,\n        chain_name: str = \"gnosis\",\n    ):\n        \"\"\"Approve ERC20 token allowance\"\"\"\n        owner_account = self.key_storage.get_account(owner_address_or_tag)\n        spender_account = self.key_storage.get_account(spender_address_or_tag)\n        spender_address = spender_account.address if spender_account else spender_address_or_tag\n\n        if not owner_account:\n            logger.error(f\"Owner account '{owner_address_or_tag}' not found in wallet.\")\n            return None\n\n        chain_interface = ChainInterfaces().get(chain_name)\n\n        token_address = self.get_token_address(token_address_or_name, chain_interface)\n        if not token_address:\n            return\n\n        erc20 = ERC20Contract(token_address, chain_name)\n\n        allowance_wei = self.get_erc20_allowance(\n            owner_address_or_tag,\n            spender_address,\n            token_address_or_name,\n            chain_name,\n        )\n        if allowance_wei is not None and allowance_wei &gt;= amount_wei:\n            logger.info(\"Current allowance is sufficient. No need to approve.\")\n            return\n\n        transaction = erc20.prepare_approve_tx(\n            from_address=owner_account.address,\n            spender=spender_address,\n            amount_wei=amount_wei,\n        )\n        if not transaction:\n            return\n\n        is_safe = isinstance(owner_account, StoredSafeAccount)\n        amount_eth = chain_interface.web3.from_wei(amount_wei, \"ether\")\n\n        logger.info(\n            f\"Approving {spender_address} to spend {amount_eth:.4f} {token_address_or_name} from {owner_address_or_tag}\"\n        )\n\n        if is_safe:\n            safe = SafeMultisig(owner_account, chain_name)\n            safe.send_tx(\n                to=erc20.address,\n                value=0,\n                signers_private_keys=self.key_storage.get_safe_signer_keys(owner_address_or_tag),\n                data=transaction[\"data\"],\n            )\n        else:\n            self.sign_and_send_transaction(transaction, owner_address_or_tag, chain_name)\n\n    def transfer_from_erc20(\n        self,\n        from_address_or_tag: str,\n        sender_address_or_tag: str,\n        recipient_address_or_tag: str,\n        token_address_or_name: str,\n        amount_wei: int,\n        chain_name: str = \"gnosis\",\n    ):\n        \"\"\"TransferFrom ERC20 tokens\"\"\"\n        from_account = self.key_storage.get_account(from_address_or_tag)\n        sender_account = self.key_storage.get_account(sender_address_or_tag)\n        recipient_account = self.key_storage.get_account(recipient_address_or_tag)\n        recipient_address = (\n            recipient_account.address if recipient_account else recipient_address_or_tag\n        )\n\n        if not sender_account:\n            logger.error(f\"Sender account '{sender_address_or_tag}' not found in wallet.\")\n            return None\n\n        chain_interface = ChainInterfaces().get(chain_name)\n\n        token_address = self.get_token_address(token_address_or_name, chain_interface)\n        if not token_address:\n            return\n\n        erc20 = ERC20Contract(token_address, chain_name)\n        transaction = erc20.prepare_transfer_from_tx(\n            from_address=from_account.address,\n            sender=sender_account.address,\n            recipient=recipient_address,\n            amount_wei=amount_wei,\n        )\n        if not transaction:\n            return\n\n        is_safe = isinstance(from_account, StoredSafeAccount)\n\n        logger.info(\"Transferring ERC20 tokens via TransferFrom\")\n\n        if is_safe:\n            safe = SafeMultisig(from_account, chain_name)\n            safe.send_tx(\n                to=erc20.address,\n                value=0,\n                signers_private_keys=self.key_storage.get_safe_signer_keys(from_address_or_tag),\n                data=transaction[\"data\"],\n            )\n        else:\n            self.sign_and_send_transaction(transaction, from_address_or_tag, chain_name)\n\n    async def swap(\n        self,\n        account_address_or_tag: str,\n        amount_eth: Optional[float],\n        sell_token_name: str,\n        buy_token_name: str,\n        chain_name: str = \"gnosis\",\n        order_type: OrderType = OrderType.SELL,\n    ) -&gt; bool:\n        \"\"\"Swap ERC-20 tokens on CowSwap.\"\"\"\n        if amount_eth is None:\n            if order_type == OrderType.BUY:\n                raise ValueError(\"Amount must be specified for buy orders.\")\n\n            logger.info(f\"Swapping entire {sell_token_name} balance to {buy_token_name}\")\n            amount_wei = self.get_erc20_balance_wei(\n                account_address_or_tag, sell_token_name, chain_name\n            )\n        else:\n            amount_wei = Web3.to_wei(amount_eth, \"ether\")\n\n        chain = ChainInterfaces().get(chain_name).chain\n        account = self.key_storage.get_account(account_address_or_tag)\n\n        retries = 1\n        max_retries = 3\n        while retries &lt; max_retries + 1:\n            # CowSwap SDK requires private key. Using unsafe access as per requirements.\n            unsafe_key = self.key_storage.get_private_key_unsafe(account.address)\n            if not unsafe_key:\n                 logger.error(f\"Could not retrieve private key for {account_address_or_tag}\")\n                 return False\n\n            cow = CowSwap(\n                private_key=unsafe_key,\n                chain=chain,\n            )\n\n            approval_amount_wei = (\n                amount_wei\n                if order_type == OrderType.SELL\n                else cow.get_max_sell_amount_wei(\n                    amount_wei,\n                    sell_token_name,\n                    buy_token_name,\n                )\n            )\n\n            self.approve_erc20(\n                owner_address_or_tag=account_address_or_tag,\n                spender_address_or_tag=COWSWAP_GPV2_VAULT_RELAYER_ADDRESS,\n                token_address_or_name=sell_token_name,\n                amount_wei=approval_amount_wei,\n                chain_name=\"gnosis\",\n            )\n\n            success = await cow.swap(\n                amount_wei=amount_wei,\n                sell_token_name=sell_token_name,\n                buy_token_name=buy_token_name,\n                order_type=order_type,\n            )\n            if success:\n                logger.info(\"Swap successful\")\n                return True\n\n            logger.error(f\"Swap try {retries}/{max_retries}] failed\")\n            retries += 1\n\n        logger.error(\"Max swap retries reached. Swap failed.\")\n\n    def drain(\n        self,\n        from_address_or_tag: str,\n        to_address_or_tag: str = \"master\",\n        chain_name: str = \"gnosis\",\n    ):\n        \"\"\"Drain entire balance of an account to another account\"\"\"\n        from_account = self.key_storage.get_account(from_address_or_tag)\n\n        if not from_account:\n            logger.error(f\"From account '{from_address_or_tag}' not found in wallet.\")\n            return\n\n        is_safe = isinstance(from_account, StoredSafeAccount)\n        chain_interface = ChainInterfaces().get(chain_name)\n\n        # ERC-20 tokens\n        for token_name in chain_interface.chain.tokens.keys():\n            balance_wei = self.get_erc20_balance_wei(from_address_or_tag, token_name, chain_name)\n            if balance_wei and balance_wei &gt; 0:\n                self.send(\n                    from_address_or_tag=from_address_or_tag,\n                    to_address_or_tag=to_address_or_tag,\n                    token_address_or_name=token_name,\n                    amount_wei=balance_wei,\n                    chain_name=chain_name,\n                )\n            else:\n                logger.info(f\"No {token_name} to drain on {from_address_or_tag}.\")\n\n        # Native currency\n        native_balance_wei = self.get_native_balance_wei(from_account.address)\n        if native_balance_wei and native_balance_wei &gt; 0:\n            if is_safe:\n                drainable_balance_wei = native_balance_wei\n            else:\n                # Estimate gas cost\n                estimated_gas = (\n                    30_000  # Basic transfer gas is 21_000 EOA-&gt;EOA. but more expensive EOA-&gt;Safe\n                )\n                gas_cost_wei = chain_interface.web3.eth.gas_price * estimated_gas\n                drainable_balance_wei = native_balance_wei - gas_cost_wei\n\n            if drainable_balance_wei &lt;= 0:\n                logger.info(\n                    f\"Not enough native balance to cover gas fees for draining from {from_address_or_tag}.\"\n                )\n                return\n\n            self.send(\n                from_address_or_tag=from_address_or_tag,\n                to_address_or_tag=to_address_or_tag,\n                token_address_or_name=NATIVE_CURRENCY_ADDRESS,\n                amount_wei=drainable_balance_wei,\n                chain_name=chain_name,\n            )\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.master_account","title":"<code>master_account</code>  <code>property</code>","text":"<p>Get master account</p>"},{"location":"core/#iwa.core.wallet.Wallet.__init__","title":"<code>__init__()</code>","text":"<p>Initialize wallet.</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize wallet.\"\"\"\n    self.key_storage = KeyStorage()\n    self.transaction_manager = TransactionManager(self.key_storage)\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.approve_erc20","title":"<code>approve_erc20(owner_address_or_tag, spender_address_or_tag, token_address_or_name, amount_wei, chain_name='gnosis')</code>","text":"<p>Approve ERC20 token allowance</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def approve_erc20(\n    self,\n    owner_address_or_tag: str,\n    spender_address_or_tag: str,\n    token_address_or_name: str,\n    amount_wei: int,\n    chain_name: str = \"gnosis\",\n):\n    \"\"\"Approve ERC20 token allowance\"\"\"\n    owner_account = self.key_storage.get_account(owner_address_or_tag)\n    spender_account = self.key_storage.get_account(spender_address_or_tag)\n    spender_address = spender_account.address if spender_account else spender_address_or_tag\n\n    if not owner_account:\n        logger.error(f\"Owner account '{owner_address_or_tag}' not found in wallet.\")\n        return None\n\n    chain_interface = ChainInterfaces().get(chain_name)\n\n    token_address = self.get_token_address(token_address_or_name, chain_interface)\n    if not token_address:\n        return\n\n    erc20 = ERC20Contract(token_address, chain_name)\n\n    allowance_wei = self.get_erc20_allowance(\n        owner_address_or_tag,\n        spender_address,\n        token_address_or_name,\n        chain_name,\n    )\n    if allowance_wei is not None and allowance_wei &gt;= amount_wei:\n        logger.info(\"Current allowance is sufficient. No need to approve.\")\n        return\n\n    transaction = erc20.prepare_approve_tx(\n        from_address=owner_account.address,\n        spender=spender_address,\n        amount_wei=amount_wei,\n    )\n    if not transaction:\n        return\n\n    is_safe = isinstance(owner_account, StoredSafeAccount)\n    amount_eth = chain_interface.web3.from_wei(amount_wei, \"ether\")\n\n    logger.info(\n        f\"Approving {spender_address} to spend {amount_eth:.4f} {token_address_or_name} from {owner_address_or_tag}\"\n    )\n\n    if is_safe:\n        safe = SafeMultisig(owner_account, chain_name)\n        safe.send_tx(\n            to=erc20.address,\n            value=0,\n            signers_private_keys=self.key_storage.get_safe_signer_keys(owner_address_or_tag),\n            data=transaction[\"data\"],\n        )\n    else:\n        self.sign_and_send_transaction(transaction, owner_address_or_tag, chain_name)\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.drain","title":"<code>drain(from_address_or_tag, to_address_or_tag='master', chain_name='gnosis')</code>","text":"<p>Drain entire balance of an account to another account</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def drain(\n    self,\n    from_address_or_tag: str,\n    to_address_or_tag: str = \"master\",\n    chain_name: str = \"gnosis\",\n):\n    \"\"\"Drain entire balance of an account to another account\"\"\"\n    from_account = self.key_storage.get_account(from_address_or_tag)\n\n    if not from_account:\n        logger.error(f\"From account '{from_address_or_tag}' not found in wallet.\")\n        return\n\n    is_safe = isinstance(from_account, StoredSafeAccount)\n    chain_interface = ChainInterfaces().get(chain_name)\n\n    # ERC-20 tokens\n    for token_name in chain_interface.chain.tokens.keys():\n        balance_wei = self.get_erc20_balance_wei(from_address_or_tag, token_name, chain_name)\n        if balance_wei and balance_wei &gt; 0:\n            self.send(\n                from_address_or_tag=from_address_or_tag,\n                to_address_or_tag=to_address_or_tag,\n                token_address_or_name=token_name,\n                amount_wei=balance_wei,\n                chain_name=chain_name,\n            )\n        else:\n            logger.info(f\"No {token_name} to drain on {from_address_or_tag}.\")\n\n    # Native currency\n    native_balance_wei = self.get_native_balance_wei(from_account.address)\n    if native_balance_wei and native_balance_wei &gt; 0:\n        if is_safe:\n            drainable_balance_wei = native_balance_wei\n        else:\n            # Estimate gas cost\n            estimated_gas = (\n                30_000  # Basic transfer gas is 21_000 EOA-&gt;EOA. but more expensive EOA-&gt;Safe\n            )\n            gas_cost_wei = chain_interface.web3.eth.gas_price * estimated_gas\n            drainable_balance_wei = native_balance_wei - gas_cost_wei\n\n        if drainable_balance_wei &lt;= 0:\n            logger.info(\n                f\"Not enough native balance to cover gas fees for draining from {from_address_or_tag}.\"\n            )\n            return\n\n        self.send(\n            from_address_or_tag=from_address_or_tag,\n            to_address_or_tag=to_address_or_tag,\n            token_address_or_name=NATIVE_CURRENCY_ADDRESS,\n            amount_wei=drainable_balance_wei,\n            chain_name=chain_name,\n        )\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.get_erc20_allowance","title":"<code>get_erc20_allowance(owner_address_or_tag, spender_address, token_address_or_name, chain_name='gnosis')</code>","text":"<p>Get ERC20 token allowance</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def get_erc20_allowance(\n    self,\n    owner_address_or_tag: str,\n    spender_address: str,\n    token_address_or_name: str,\n    chain_name: str = \"gnosis\",\n) -&gt; Optional[float]:\n    \"\"\"Get ERC20 token allowance\"\"\"\n    chain = ChainInterfaces().get(chain_name)\n\n    token_address = self.get_token_address(token_address_or_name, chain.chain)\n    if not token_address:\n        return None\n\n    owner_account = self.key_storage.get_account(owner_address_or_tag)\n    if not owner_account:\n        return None\n\n    contract = ERC20Contract(chain_name=chain_name, address=token_address)\n    return contract.allowance_wei(owner_account.address, spender_address)\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.get_erc20_balance_eth","title":"<code>get_erc20_balance_eth(account_address_or_tag, token_address_or_name, chain_name='gnosis')</code>","text":"<p>Get ERC20 token balance</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def get_erc20_balance_eth(\n    self, account_address_or_tag: str, token_address_or_name: str, chain_name: str = \"gnosis\"\n) -&gt; Optional[float]:\n    \"\"\"Get ERC20 token balance\"\"\"\n    chain = ChainInterfaces().get(chain_name)\n\n    token_address = self.get_token_address(token_address_or_name, chain.chain)\n    if not token_address:\n        return None\n\n    account = self.key_storage.get_account(account_address_or_tag)\n    if not account:\n        return None\n\n    contract = ERC20Contract(chain_name=chain_name, address=token_address)\n    return contract.balance_of_eth(account.address)\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.get_erc20_balance_wei","title":"<code>get_erc20_balance_wei(account_address_or_tag, token_address_or_name, chain_name='gnosis')</code>","text":"<p>Get ERC20 token balance</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def get_erc20_balance_wei(\n    self, account_address_or_tag: str, token_address_or_name: str, chain_name: str = \"gnosis\"\n) -&gt; Optional[int]:\n    \"\"\"Get ERC20 token balance\"\"\"\n    chain = ChainInterfaces().get(chain_name)\n\n    token_address = self.get_token_address(token_address_or_name, chain.chain)\n    if not token_address:\n        return None\n\n    account = self.key_storage.get_account(account_address_or_tag)\n    if not account:\n        return None\n\n    contract = ERC20Contract(chain_name=chain_name, address=token_address)\n    return contract.balance_of_wei(account.address)\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.get_native_balance_eth","title":"<code>get_native_balance_eth(account_address, chain_name='gnosis')</code>","text":"<p>Get native currency balance</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def get_native_balance_eth(\n    self, account_address: str, chain_name: str = \"gnosis\"\n) -&gt; Optional[float]:\n    \"\"\"Get native currency balance\"\"\"\n    chain_interface = ChainInterfaces().get(chain_name)\n    return chain_interface.get_native_balance_eth(account_address)\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.get_native_balance_wei","title":"<code>get_native_balance_wei(account_address, chain_name='gnosis')</code>","text":"<p>Get native currency balance</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def get_native_balance_wei(\n    self, account_address: str, chain_name: str = \"gnosis\"\n) -&gt; Optional[int]:\n    \"\"\"Get native currency balance\"\"\"\n    chain_interface = ChainInterfaces().get(chain_name)\n    return chain_interface.get_native_balance_wei(account_address)\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.get_token_address","title":"<code>get_token_address(token_address_or_name, chain)</code>","text":"<p>Get token address from address or name</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def get_token_address(\n    self, token_address_or_name: str, chain: SupportedChain\n) -&gt; Optional[EthereumAddress]:\n    \"\"\"Get token address from address or name\"\"\"\n    if token_address_or_name == \"native\":\n        return EthereumAddress(NATIVE_CURRENCY_ADDRESS)\n\n    try:\n        token_address = EthereumAddress(token_address_or_name)\n        return token_address\n    except ValueError:\n        token_address = chain.get_token_address(token_address_or_name)\n        if not token_address:\n            logger.error(f\"Token '{token_address_or_name}' not found on chain '{chain.name}'.\")\n            return None\n        return token_address\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.list_accounts","title":"<code>list_accounts(chain_name, balances=None)</code>","text":"<p>List accounts</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def list_accounts(self, chain_name: str, balances: Optional[str] = None) -&gt; None:\n    \"\"\"List accounts\"\"\"\n    chain_interface = ChainInterfaces().get(chain_name)\n    token_names = balances.split(\",\") if balances else []\n\n    token_balances = (\n        {\n            account_address: {\n                token_name: self.get_erc20_balance_eth(account_address, token_name)\n                if token_name != \"native\"\n                else chain_interface.get_native_balance_eth(account_address)\n                for token_name in token_names\n            }\n            for account_address in self.key_storage.accounts.keys()\n        }\n        if token_names\n        else None\n    )\n\n    list_accounts(self.key_storage.accounts, chain_interface, token_names, token_balances)\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.multi_send","title":"<code>multi_send(from_address_or_tag, transactions, chain_name='gnosis')</code>","text":"<p>Send multiple transactions in a single multisend transaction</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def multi_send(\n    self,\n    from_address_or_tag: str,\n    transactions: list,\n    chain_name: str = \"gnosis\",\n):\n    \"\"\"Send multiple transactions in a single multisend transaction\"\"\"\n    from_account = self.key_storage.get_account(from_address_or_tag)\n    is_safe = isinstance(from_account, StoredSafeAccount)\n\n    if not from_account:\n        logger.error(f\"From account '{from_address_or_tag}' not found in wallet.\")\n        return\n\n    chain_interface = ChainInterfaces().get(chain_name)\n\n    is_all_native = all(\n        tx.get(\"token\", NATIVE_CURRENCY_ADDRESS) == NATIVE_CURRENCY_ADDRESS\n        for tx in transactions\n    )\n\n    if not is_safe and not is_all_native:\n        raise ValueError(\"Multisend with ERC20 tokens requires a Safe account.\")\n\n    for tx in transactions:\n        to = self.key_storage.get_account(tx[\"to\"])\n        recipient_address = to.address if to else tx[\"to\"]\n        amount_wei = chain_interface.web3.to_wei(tx[\"amount\"], \"ether\")\n        token_address_or_tag = tx.get(\"token\", NATIVE_CURRENCY_ADDRESS)\n        if \"amount\" in tx:\n            del tx[\"amount\"]\n        if \"token\" in tx:\n            del tx[\"token\"]\n\n        if token_address_or_tag == NATIVE_CURRENCY_ADDRESS:\n            tx[\"to\"] = recipient_address\n            tx[\"value\"] = amount_wei\n            tx[\"data\"] = b\"\"\n            tx[\"operation\"] = SafeOperationEnum.CALL\n\n        else:\n            token_address = self.get_token_address(token_address_or_tag, chain_interface.chain)\n            erc20 = ERC20Contract(token_address, chain_name)\n            transfer_tx = erc20.prepare_transfer_tx(\n                from_address=from_account.address,\n                to=recipient_address,\n                amount_wei=amount_wei,\n            )\n            tx[\"to\"] = erc20.address\n            tx[\"value\"] = 0\n            tx[\"data\"] = transfer_tx[\"data\"]\n            tx[\"operation\"] = SafeOperationEnum.CALL\n\n    multi_send_normal_contract = MultiSendContract(\n        address=MULTISEND_ADDRESS_GNOSIS, chain_name=chain_name\n    )\n    multi_send_call_only_contract = MultiSendCallOnlyContract(\n        address=MULTISEND_CALL_ONLY_ADDRESS_GNOSIS, chain_name=chain_name\n    )\n\n    multi_send_contract = (\n        multi_send_normal_contract if is_safe else multi_send_call_only_contract\n    )\n    transaction = multi_send_contract.prepare_tx(\n        from_address=from_account.address, transactions=transactions\n    )\n    if not transaction:\n        return\n\n    logger.info(\"Sending multisend transaction\")\n\n    if is_safe:\n        safe = SafeMultisig(from_account, chain_name)\n        safe.send_tx(\n            to=multi_send_contract.address,\n            value=transaction[\"value\"],\n            signers_private_keys=self.key_storage.get_safe_signer_keys(from_address_or_tag),\n            data=transaction[\"data\"],\n            operation=SafeOperationEnum.DELEGATE_CALL.value,\n        )\n    else:\n        self.sign_and_send_transaction(transaction, from_address_or_tag, chain_name)\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.send","title":"<code>send(from_address_or_tag, to_address_or_tag, token_address_or_name, amount_wei, chain_name='gnosis')</code>","text":"<p>Send native currency or ERC20 tokens to an address</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def send(\n    self,\n    from_address_or_tag: str,\n    to_address_or_tag: str,\n    token_address_or_name: str,\n    amount_wei: int,\n    chain_name: str = \"gnosis\",\n):\n    \"\"\"Send native currency or ERC20 tokens to an address\"\"\"\n    from_account = self.key_storage.get_account(from_address_or_tag)\n    to_account = self.key_storage.get_account(to_address_or_tag)\n    to_address = to_account.address if to_account else to_address_or_tag\n\n    if not from_account:\n        logger.error(f\"From account '{from_address_or_tag}' not found in wallet.\")\n        return\n\n    chain_interface = ChainInterfaces().get(chain_name)\n\n    token_address = self.get_token_address(token_address_or_name, chain_interface.chain)\n    if not token_address:\n        return\n\n    is_safe = isinstance(from_account, StoredSafeAccount)\n\n    if token_address == NATIVE_CURRENCY_ADDRESS:\n        logger.info(\n            f\"Sending {chain_interface.web3.from_wei(amount_wei, 'ether'):.4f} {chain_interface.chain.native_currency} from {from_address_or_tag} to {to_address_or_tag}\"\n        )\n        if is_safe:\n            safe = SafeMultisig(from_account, chain_name)\n            safe.send_tx(\n                to=to_address,\n                value=amount_wei,\n                signers_private_keys=self.key_storage.get_safe_signer_keys(from_address_or_tag),\n            )\n\n        else:\n            chain_interface.send_native_transfer(\n                from_account=from_account,\n                to_address=to_address,\n                value_wei=amount_wei,\n            )\n        return\n\n    erc20 = ERC20Contract(token_address)\n    transaction = erc20.prepare_transfer_tx(\n        from_account.address,\n        to_address,\n        amount_wei,\n    )\n    if not transaction:\n        return\n\n    amount_eth = chain_interface.web3.from_wei(amount_wei, \"ether\")\n    logger.info(\n        f\"Sending {amount_eth:.4f} {token_address_or_name} from {from_address_or_tag} to {to_address_or_tag}\"\n    )\n\n    if is_safe:\n        safe = SafeMultisig(from_account, chain_name)\n        safe.send_tx(\n            to=erc20.address,\n            value=0,\n            signers_private_keys=self.key_storage.get_safe_signer_keys(from_address_or_tag),\n            data=transaction[\"data\"],\n        )\n    else:\n        self.sign_and_send_transaction(transaction, from_address_or_tag, chain_name)\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.sign_and_send_transaction","title":"<code>sign_and_send_transaction(transaction, signer_address_or_tag, chain_name='gnosis')</code>","text":"<p>Sign and send transaction</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def sign_and_send_transaction(\n    self, transaction: dict, signer_address_or_tag: str, chain_name: str = \"gnosis\"\n) -&gt; Tuple[bool, Dict]:\n    \"\"\"Sign and send transaction\"\"\"\n    return self.transaction_manager.sign_and_send(\n        transaction, signer_address_or_tag, chain_name\n    )\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.swap","title":"<code>swap(account_address_or_tag, amount_eth, sell_token_name, buy_token_name, chain_name='gnosis', order_type=OrderType.SELL)</code>  <code>async</code>","text":"<p>Swap ERC-20 tokens on CowSwap.</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>async def swap(\n    self,\n    account_address_or_tag: str,\n    amount_eth: Optional[float],\n    sell_token_name: str,\n    buy_token_name: str,\n    chain_name: str = \"gnosis\",\n    order_type: OrderType = OrderType.SELL,\n) -&gt; bool:\n    \"\"\"Swap ERC-20 tokens on CowSwap.\"\"\"\n    if amount_eth is None:\n        if order_type == OrderType.BUY:\n            raise ValueError(\"Amount must be specified for buy orders.\")\n\n        logger.info(f\"Swapping entire {sell_token_name} balance to {buy_token_name}\")\n        amount_wei = self.get_erc20_balance_wei(\n            account_address_or_tag, sell_token_name, chain_name\n        )\n    else:\n        amount_wei = Web3.to_wei(amount_eth, \"ether\")\n\n    chain = ChainInterfaces().get(chain_name).chain\n    account = self.key_storage.get_account(account_address_or_tag)\n\n    retries = 1\n    max_retries = 3\n    while retries &lt; max_retries + 1:\n        # CowSwap SDK requires private key. Using unsafe access as per requirements.\n        unsafe_key = self.key_storage.get_private_key_unsafe(account.address)\n        if not unsafe_key:\n             logger.error(f\"Could not retrieve private key for {account_address_or_tag}\")\n             return False\n\n        cow = CowSwap(\n            private_key=unsafe_key,\n            chain=chain,\n        )\n\n        approval_amount_wei = (\n            amount_wei\n            if order_type == OrderType.SELL\n            else cow.get_max_sell_amount_wei(\n                amount_wei,\n                sell_token_name,\n                buy_token_name,\n            )\n        )\n\n        self.approve_erc20(\n            owner_address_or_tag=account_address_or_tag,\n            spender_address_or_tag=COWSWAP_GPV2_VAULT_RELAYER_ADDRESS,\n            token_address_or_name=sell_token_name,\n            amount_wei=approval_amount_wei,\n            chain_name=\"gnosis\",\n        )\n\n        success = await cow.swap(\n            amount_wei=amount_wei,\n            sell_token_name=sell_token_name,\n            buy_token_name=buy_token_name,\n            order_type=order_type,\n        )\n        if success:\n            logger.info(\"Swap successful\")\n            return True\n\n        logger.error(f\"Swap try {retries}/{max_retries}] failed\")\n        retries += 1\n\n    logger.error(\"Max swap retries reached. Swap failed.\")\n</code></pre>"},{"location":"core/#iwa.core.wallet.Wallet.transfer_from_erc20","title":"<code>transfer_from_erc20(from_address_or_tag, sender_address_or_tag, recipient_address_or_tag, token_address_or_name, amount_wei, chain_name='gnosis')</code>","text":"<p>TransferFrom ERC20 tokens</p> Source code in <code>src/iwa/core/wallet.py</code> <pre><code>def transfer_from_erc20(\n    self,\n    from_address_or_tag: str,\n    sender_address_or_tag: str,\n    recipient_address_or_tag: str,\n    token_address_or_name: str,\n    amount_wei: int,\n    chain_name: str = \"gnosis\",\n):\n    \"\"\"TransferFrom ERC20 tokens\"\"\"\n    from_account = self.key_storage.get_account(from_address_or_tag)\n    sender_account = self.key_storage.get_account(sender_address_or_tag)\n    recipient_account = self.key_storage.get_account(recipient_address_or_tag)\n    recipient_address = (\n        recipient_account.address if recipient_account else recipient_address_or_tag\n    )\n\n    if not sender_account:\n        logger.error(f\"Sender account '{sender_address_or_tag}' not found in wallet.\")\n        return None\n\n    chain_interface = ChainInterfaces().get(chain_name)\n\n    token_address = self.get_token_address(token_address_or_name, chain_interface)\n    if not token_address:\n        return\n\n    erc20 = ERC20Contract(token_address, chain_name)\n    transaction = erc20.prepare_transfer_from_tx(\n        from_address=from_account.address,\n        sender=sender_account.address,\n        recipient=recipient_address,\n        amount_wei=amount_wei,\n    )\n    if not transaction:\n        return\n\n    is_safe = isinstance(from_account, StoredSafeAccount)\n\n    logger.info(\"Transferring ERC20 tokens via TransferFrom\")\n\n    if is_safe:\n        safe = SafeMultisig(from_account, chain_name)\n        safe.send_tx(\n            to=erc20.address,\n            value=0,\n            signers_private_keys=self.key_storage.get_safe_signer_keys(from_address_or_tag),\n            data=transaction[\"data\"],\n        )\n    else:\n        self.sign_and_send_transaction(transaction, from_address_or_tag, chain_name)\n</code></pre>"},{"location":"core/#transaction-manager","title":"Transaction Manager","text":""},{"location":"core/#iwa.core.managers","title":"<code>iwa.core.managers</code>","text":"<p>Managers for transaction and chain interactions.</p>"},{"location":"core/#iwa.core.managers.TransactionManager","title":"<code>TransactionManager</code>","text":"<p>Manages transaction lifecycle: signing, sending, retrying.</p> Source code in <code>src/iwa/core/managers.py</code> <pre><code>class TransactionManager:\n    \"\"\"Manages transaction lifecycle: signing, sending, retrying.\"\"\"\n\n    def __init__(self, key_storage: KeyStorage):\n        \"\"\"Initialize TransactionManager.\"\"\"\n        self.key_storage = key_storage\n\n    def sign_and_send(\n        self,\n        transaction: dict,\n        signer_address_or_tag: str,\n        chain_name: str = \"gnosis\",\n    ) -&gt; Tuple[bool, Dict]:\n        \"\"\"Sign and send a transaction with retry logic for gas.\"\"\"\n        chain_interface = ChainInterfaces().get(chain_name)\n        tx = dict(transaction)\n        max_retries = 3\n\n        # Ensure nonce is set if not present\n        if \"nonce\" not in tx:\n             signer_account = self.key_storage.get_account(signer_address_or_tag)\n             if not signer_account:\n                 logger.error(f\"Signer {signer_address_or_tag} not found\")\n                 return False, {}\n             tx[\"nonce\"] = chain_interface.web3.eth.get_transaction_count(signer_account.address)\n\n        if \"chainId\" not in tx:\n            tx[\"chainId\"] = chain_interface.chain.chain_id\n\n        for attempt in range(1, max_retries + 1):\n            try:\n                # Sign\n                signed_txn = self.key_storage.sign_transaction(tx, signer_address_or_tag)\n\n                # Send\n                txn_hash = chain_interface.web3.eth.send_raw_transaction(signed_txn.rawTransaction)\n\n                # Wait\n                receipt = chain_interface.web3.eth.wait_for_transaction_receipt(txn_hash)\n\n                if receipt and getattr(receipt, \"status\", None) == 1:\n                    signer_account = self.key_storage.get_account(signer_address_or_tag)\n                    chain_interface.wait_for_no_pending_tx(signer_account.address)\n                    logger.info(f\"Transaction sent successfully. Tx Hash: {txn_hash.hex()}\")\n                    return True, receipt\n\n                logger.error(\"Transaction failed (status 0).\")\n                return False, {}\n\n            except web3_exceptions.Web3RPCError as e:\n                err_text = str(e)\n                if self._is_gas_too_low_error(err_text) and attempt &lt; max_retries:\n                    logger.warning(\n                        f\"Gas too low error detected. Retrying with increased gas (Attempt {attempt}/{max_retries})...\"\n                    )\n                    current_gas = int(tx.get(\"gas\", 30_000))\n                    tx[\"gas\"] = int(current_gas * 1.5)\n                    time.sleep(0.5 * attempt)  # backoff\n                    continue\n                else:\n                    logger.exception(f\"Error sending transaction: {e}\")\n                    return False, {}\n\n            except Exception as e:\n                # Attempt RPC rotation on failure if it's likely a connection/node issue\n                # Differentiating is hard, so we might rotate on unknown errors too if we haven't exhausted attempts yet\n                if attempt &lt; max_retries:\n                    logger.warning(f\"Error encountered: {e}. Attempting to rotate RPC...\")\n                    rotated = chain_interface.rotate_rpc()\n                    if rotated:\n                        logger.info(\"Retrying with new RPC...\")\n                        time.sleep(0.5 * attempt)\n                        continue\n\n                logger.exception(f\"Unexpected error sending transaction: {e}\")\n                return False, {}\n\n        return False, {}\n\n    def _is_gas_too_low_error(self, err_text: str) -&gt; bool:\n        \"\"\"Check if error is due to low gas.\"\"\"\n        low_gas_signals = [\"feetoolow\", \"intrinsic gas too low\", \"replacement transaction underpriced\"]\n        text = (err_text or \"\").lower()\n        return any(sig in text for sig in low_gas_signals)\n</code></pre>"},{"location":"core/#iwa.core.managers.TransactionManager.__init__","title":"<code>__init__(key_storage)</code>","text":"<p>Initialize TransactionManager.</p> Source code in <code>src/iwa/core/managers.py</code> <pre><code>def __init__(self, key_storage: KeyStorage):\n    \"\"\"Initialize TransactionManager.\"\"\"\n    self.key_storage = key_storage\n</code></pre>"},{"location":"core/#iwa.core.managers.TransactionManager.sign_and_send","title":"<code>sign_and_send(transaction, signer_address_or_tag, chain_name='gnosis')</code>","text":"<p>Sign and send a transaction with retry logic for gas.</p> Source code in <code>src/iwa/core/managers.py</code> <pre><code>def sign_and_send(\n    self,\n    transaction: dict,\n    signer_address_or_tag: str,\n    chain_name: str = \"gnosis\",\n) -&gt; Tuple[bool, Dict]:\n    \"\"\"Sign and send a transaction with retry logic for gas.\"\"\"\n    chain_interface = ChainInterfaces().get(chain_name)\n    tx = dict(transaction)\n    max_retries = 3\n\n    # Ensure nonce is set if not present\n    if \"nonce\" not in tx:\n         signer_account = self.key_storage.get_account(signer_address_or_tag)\n         if not signer_account:\n             logger.error(f\"Signer {signer_address_or_tag} not found\")\n             return False, {}\n         tx[\"nonce\"] = chain_interface.web3.eth.get_transaction_count(signer_account.address)\n\n    if \"chainId\" not in tx:\n        tx[\"chainId\"] = chain_interface.chain.chain_id\n\n    for attempt in range(1, max_retries + 1):\n        try:\n            # Sign\n            signed_txn = self.key_storage.sign_transaction(tx, signer_address_or_tag)\n\n            # Send\n            txn_hash = chain_interface.web3.eth.send_raw_transaction(signed_txn.rawTransaction)\n\n            # Wait\n            receipt = chain_interface.web3.eth.wait_for_transaction_receipt(txn_hash)\n\n            if receipt and getattr(receipt, \"status\", None) == 1:\n                signer_account = self.key_storage.get_account(signer_address_or_tag)\n                chain_interface.wait_for_no_pending_tx(signer_account.address)\n                logger.info(f\"Transaction sent successfully. Tx Hash: {txn_hash.hex()}\")\n                return True, receipt\n\n            logger.error(\"Transaction failed (status 0).\")\n            return False, {}\n\n        except web3_exceptions.Web3RPCError as e:\n            err_text = str(e)\n            if self._is_gas_too_low_error(err_text) and attempt &lt; max_retries:\n                logger.warning(\n                    f\"Gas too low error detected. Retrying with increased gas (Attempt {attempt}/{max_retries})...\"\n                )\n                current_gas = int(tx.get(\"gas\", 30_000))\n                tx[\"gas\"] = int(current_gas * 1.5)\n                time.sleep(0.5 * attempt)  # backoff\n                continue\n            else:\n                logger.exception(f\"Error sending transaction: {e}\")\n                return False, {}\n\n        except Exception as e:\n            # Attempt RPC rotation on failure if it's likely a connection/node issue\n            # Differentiating is hard, so we might rotate on unknown errors too if we haven't exhausted attempts yet\n            if attempt &lt; max_retries:\n                logger.warning(f\"Error encountered: {e}. Attempting to rotate RPC...\")\n                rotated = chain_interface.rotate_rpc()\n                if rotated:\n                    logger.info(\"Retrying with new RPC...\")\n                    time.sleep(0.5 * attempt)\n                    continue\n\n            logger.exception(f\"Unexpected error sending transaction: {e}\")\n            return False, {}\n\n    return False, {}\n</code></pre>"},{"location":"core/#chain-interface","title":"Chain Interface","text":""},{"location":"core/#iwa.core.chain","title":"<code>iwa.core.chain</code>","text":"<p>Chain interaction helpers.</p>"},{"location":"core/#iwa.core.chain.ChainInterface","title":"<code>ChainInterface</code>","text":"<p>ChainInterface</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>class ChainInterface:\n    \"\"\"ChainInterface\"\"\"\n\n    def __init__(self, chain: Union[SupportedChain, str] = None):\n        \"\"\"ChainInterface\"\"\"\n        if chain is None:\n            chain = Gnosis()\n        if isinstance(chain, str):\n            chain: SupportedChain = getattr(SupportedChains(), chain.lower())\n\n        self.chain = chain\n\n        if self.chain.rpc and self.chain.rpc.startswith(\"http://\"):\n            logger.warning(f\"Using insecure RPC URL for {self.chain.name}: {self.chain.rpc}. Please use HTTPS.\")\n\n        self.web3 = Web3(Web3.HTTPProvider(self.chain.rpc))\n        self._current_rpc_index = 0\n\n    def rotate_rpc(self) -&gt; bool:\n        \"\"\"Rotate to the next available RPC.\"\"\"\n        if not self.chain.rpcs or len(self.chain.rpcs) &lt;= 1:\n            return False\n\n        self._current_rpc_index = (self._current_rpc_index + 1) % len(self.chain.rpcs)\n        new_rpc = self.chain.rpcs[self._current_rpc_index]\n        logger.info(f\"Rotating RPC for {self.chain.name} to {new_rpc}\")\n        self.web3 = Web3(Web3.HTTPProvider(new_rpc))\n        return True\n\n    def is_contract(self, address: str) -&gt; bool:\n        \"\"\"Check if address is a contract\"\"\"\n        code = self.web3.eth.get_code(address)\n        return code != b\"\"\n\n    def get_native_balance_wei(self, address: str):\n        \"\"\"Get the native balance in wei\"\"\"\n        return self.web3.eth.get_balance(address)\n\n    def get_native_balance_eth(self, address: str):\n        \"\"\"Get the native balance in ether\"\"\"\n        balance_wei = self.get_native_balance_wei(address)\n        balance_ether = self.web3.from_wei(balance_wei, \"ether\")\n        return balance_ether\n\n    def sign_and_send_transaction(self, transaction: dict, private_key: str) -&gt; Tuple[bool, Dict]:\n        \"\"\"Sign and send a transaction.\"\"\"\n        max_retries = 3\n        tx = dict(transaction)\n\n        def _is_gas_too_low_error(err_text: str) -&gt; bool:\n            low_gas_signals = [\n                \"feetoolow\",\n            ]\n            text = (err_text or \"\").lower()\n            return any(sig in text for sig in low_gas_signals)\n\n        for attempt in range(1, max_retries + 1):\n            try:\n                signed_txn = self.web3.eth.account.sign_transaction(tx, private_key=private_key)\n                txn_hash = self.web3.eth.send_raw_transaction(signed_txn.raw_transaction)\n                receipt = self.web3.eth.wait_for_transaction_receipt(txn_hash)\n                if receipt and getattr(receipt, \"status\", None) == 1:\n                    self.wait_for_no_pending_tx(transaction[\"from\"])\n                    logger.info(f\"Transaction sent successfully. Tx Hash: {txn_hash.hex()}\")\n                    return True, receipt\n\n                logger.error(\"Transaction failed.\")\n                return False, {}\n\n            except web3_exceptions.Web3RPCError as e:\n                err_text = str(e)\n                if _is_gas_too_low_error(err_text) and attempt &lt; max_retries:\n                    logger.warning(\n                        f\"Gas too low error detected. Retrying with increased gas (Attempt {attempt}/{max_retries})...\"\n                    )\n                    current_gas = int(tx.get(\"gas\", 30_000))\n                    tx[\"gas\"] = int(current_gas * 1.5)\n                    time.sleep(0.5 * attempt)  # backoff\n                    continue\n                else:\n                    logger.exception(f\"Error sending transaction: {e}\")\n                    return False, {}\n\n            except Exception as e:\n                logger.exception(f\"Unexpected error sending transaction: {e}\")\n                return False, {}\n\n\n\n    def estimate_gas(self, built_method, tx_params) -&gt; int:\n        \"\"\"Estimate gas for a contract function call.\"\"\"\n        from_address = tx_params[\"from\"]\n        value = tx_params.get(\"value\", 0)\n        estimated_gas = (\n            0\n            if self.is_contract(from_address)\n            else built_method.estimate_gas({\"from\": from_address, \"value\": value})\n        )\n        return int(estimated_gas * 1.1)\n\n    def calculate_transaction_params(self, built_method, tx_params) -&gt; dict:\n        \"\"\"Calculate transaction parameters for a contract function call.\"\"\"\n        params = {\n            \"from\": tx_params[\"from\"],\n            \"value\": tx_params.get(\"value\", 0),\n            \"nonce\": self.web3.eth.get_transaction_count(tx_params[\"from\"]),\n            \"gas\": self.estimate_gas(built_method, tx_params),\n            \"gasPrice\": self.web3.eth.gas_price,\n        }\n        return params\n\n    def wait_for_no_pending_tx(\n        self, from_address: str, max_wait_seconds: int = 60, poll_interval: float = 2.0\n    ):\n        \"\"\"Wait for no pending transactions for a specified time.\"\"\"\n        start_time = time.time()\n        while time.time() - start_time &lt; max_wait_seconds:\n            latest_nonce = self.web3.eth.get_transaction_count(\n                from_address, block_identifier=\"latest\"\n            )\n            pending_nonce = self.web3.eth.get_transaction_count(\n                from_address, block_identifier=\"pending\"\n            )\n\n            if pending_nonce == latest_nonce:\n                return True\n\n            time.sleep(poll_interval)\n\n        return False\n\n    def send_native_transfer(\n        self,\n        from_account: Account,\n        to_address: EthereumAddress,\n        value_wei: int,\n    ) -&gt; bool:\n        \"\"\"Send native currency transaction\"\"\"\n        tx = {\n            \"from\": from_account.address,\n            \"to\": to_address,\n            \"value\": value_wei,\n            \"nonce\": self.web3.eth.get_transaction_count(from_account.address),\n            \"chainId\": self.chain.chain_id,\n        }\n\n        balance_wei = self.get_native_balance_wei(from_account.address)\n        gas_price = self.web3.eth.gas_price\n        gas_estimate = self.web3.eth.estimate_gas(tx)\n        required_wei = value_wei + (gas_estimate * gas_price)\n\n        if balance_wei &lt; required_wei:\n            logger.error(\n                f\"Insufficient balance to cover amount and gas fees.\\nBalance: {self.web3.from_wei(balance_wei, 'ether'):.2f} {self.chain.native_currency}, Required: {self.web3.from_wei(required_wei, 'ether'):.2f} {self.chain.native_currency}\"\n            )\n            return False\n\n        tx[\"gas\"] = gas_estimate\n        tx[\"gasPrice\"] = gas_price\n\n        success, receipt = self.sign_and_send_transaction(tx, from_account.key)\n        return success\n\n    def get_token_address(self, token_name: str) -&gt; Optional[EthereumAddress]:\n        \"\"\"Get token address by name\"\"\"\n        return self.chain.get_token_address(token_name)\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.__init__","title":"<code>__init__(chain=None)</code>","text":"<p>ChainInterface</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def __init__(self, chain: Union[SupportedChain, str] = None):\n    \"\"\"ChainInterface\"\"\"\n    if chain is None:\n        chain = Gnosis()\n    if isinstance(chain, str):\n        chain: SupportedChain = getattr(SupportedChains(), chain.lower())\n\n    self.chain = chain\n\n    if self.chain.rpc and self.chain.rpc.startswith(\"http://\"):\n        logger.warning(f\"Using insecure RPC URL for {self.chain.name}: {self.chain.rpc}. Please use HTTPS.\")\n\n    self.web3 = Web3(Web3.HTTPProvider(self.chain.rpc))\n    self._current_rpc_index = 0\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.calculate_transaction_params","title":"<code>calculate_transaction_params(built_method, tx_params)</code>","text":"<p>Calculate transaction parameters for a contract function call.</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def calculate_transaction_params(self, built_method, tx_params) -&gt; dict:\n    \"\"\"Calculate transaction parameters for a contract function call.\"\"\"\n    params = {\n        \"from\": tx_params[\"from\"],\n        \"value\": tx_params.get(\"value\", 0),\n        \"nonce\": self.web3.eth.get_transaction_count(tx_params[\"from\"]),\n        \"gas\": self.estimate_gas(built_method, tx_params),\n        \"gasPrice\": self.web3.eth.gas_price,\n    }\n    return params\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.estimate_gas","title":"<code>estimate_gas(built_method, tx_params)</code>","text":"<p>Estimate gas for a contract function call.</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def estimate_gas(self, built_method, tx_params) -&gt; int:\n    \"\"\"Estimate gas for a contract function call.\"\"\"\n    from_address = tx_params[\"from\"]\n    value = tx_params.get(\"value\", 0)\n    estimated_gas = (\n        0\n        if self.is_contract(from_address)\n        else built_method.estimate_gas({\"from\": from_address, \"value\": value})\n    )\n    return int(estimated_gas * 1.1)\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.get_native_balance_eth","title":"<code>get_native_balance_eth(address)</code>","text":"<p>Get the native balance in ether</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def get_native_balance_eth(self, address: str):\n    \"\"\"Get the native balance in ether\"\"\"\n    balance_wei = self.get_native_balance_wei(address)\n    balance_ether = self.web3.from_wei(balance_wei, \"ether\")\n    return balance_ether\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.get_native_balance_wei","title":"<code>get_native_balance_wei(address)</code>","text":"<p>Get the native balance in wei</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def get_native_balance_wei(self, address: str):\n    \"\"\"Get the native balance in wei\"\"\"\n    return self.web3.eth.get_balance(address)\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.get_token_address","title":"<code>get_token_address(token_name)</code>","text":"<p>Get token address by name</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def get_token_address(self, token_name: str) -&gt; Optional[EthereumAddress]:\n    \"\"\"Get token address by name\"\"\"\n    return self.chain.get_token_address(token_name)\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.is_contract","title":"<code>is_contract(address)</code>","text":"<p>Check if address is a contract</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def is_contract(self, address: str) -&gt; bool:\n    \"\"\"Check if address is a contract\"\"\"\n    code = self.web3.eth.get_code(address)\n    return code != b\"\"\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.rotate_rpc","title":"<code>rotate_rpc()</code>","text":"<p>Rotate to the next available RPC.</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def rotate_rpc(self) -&gt; bool:\n    \"\"\"Rotate to the next available RPC.\"\"\"\n    if not self.chain.rpcs or len(self.chain.rpcs) &lt;= 1:\n        return False\n\n    self._current_rpc_index = (self._current_rpc_index + 1) % len(self.chain.rpcs)\n    new_rpc = self.chain.rpcs[self._current_rpc_index]\n    logger.info(f\"Rotating RPC for {self.chain.name} to {new_rpc}\")\n    self.web3 = Web3(Web3.HTTPProvider(new_rpc))\n    return True\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.send_native_transfer","title":"<code>send_native_transfer(from_account, to_address, value_wei)</code>","text":"<p>Send native currency transaction</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def send_native_transfer(\n    self,\n    from_account: Account,\n    to_address: EthereumAddress,\n    value_wei: int,\n) -&gt; bool:\n    \"\"\"Send native currency transaction\"\"\"\n    tx = {\n        \"from\": from_account.address,\n        \"to\": to_address,\n        \"value\": value_wei,\n        \"nonce\": self.web3.eth.get_transaction_count(from_account.address),\n        \"chainId\": self.chain.chain_id,\n    }\n\n    balance_wei = self.get_native_balance_wei(from_account.address)\n    gas_price = self.web3.eth.gas_price\n    gas_estimate = self.web3.eth.estimate_gas(tx)\n    required_wei = value_wei + (gas_estimate * gas_price)\n\n    if balance_wei &lt; required_wei:\n        logger.error(\n            f\"Insufficient balance to cover amount and gas fees.\\nBalance: {self.web3.from_wei(balance_wei, 'ether'):.2f} {self.chain.native_currency}, Required: {self.web3.from_wei(required_wei, 'ether'):.2f} {self.chain.native_currency}\"\n        )\n        return False\n\n    tx[\"gas\"] = gas_estimate\n    tx[\"gasPrice\"] = gas_price\n\n    success, receipt = self.sign_and_send_transaction(tx, from_account.key)\n    return success\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.sign_and_send_transaction","title":"<code>sign_and_send_transaction(transaction, private_key)</code>","text":"<p>Sign and send a transaction.</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def sign_and_send_transaction(self, transaction: dict, private_key: str) -&gt; Tuple[bool, Dict]:\n    \"\"\"Sign and send a transaction.\"\"\"\n    max_retries = 3\n    tx = dict(transaction)\n\n    def _is_gas_too_low_error(err_text: str) -&gt; bool:\n        low_gas_signals = [\n            \"feetoolow\",\n        ]\n        text = (err_text or \"\").lower()\n        return any(sig in text for sig in low_gas_signals)\n\n    for attempt in range(1, max_retries + 1):\n        try:\n            signed_txn = self.web3.eth.account.sign_transaction(tx, private_key=private_key)\n            txn_hash = self.web3.eth.send_raw_transaction(signed_txn.raw_transaction)\n            receipt = self.web3.eth.wait_for_transaction_receipt(txn_hash)\n            if receipt and getattr(receipt, \"status\", None) == 1:\n                self.wait_for_no_pending_tx(transaction[\"from\"])\n                logger.info(f\"Transaction sent successfully. Tx Hash: {txn_hash.hex()}\")\n                return True, receipt\n\n            logger.error(\"Transaction failed.\")\n            return False, {}\n\n        except web3_exceptions.Web3RPCError as e:\n            err_text = str(e)\n            if _is_gas_too_low_error(err_text) and attempt &lt; max_retries:\n                logger.warning(\n                    f\"Gas too low error detected. Retrying with increased gas (Attempt {attempt}/{max_retries})...\"\n                )\n                current_gas = int(tx.get(\"gas\", 30_000))\n                tx[\"gas\"] = int(current_gas * 1.5)\n                time.sleep(0.5 * attempt)  # backoff\n                continue\n            else:\n                logger.exception(f\"Error sending transaction: {e}\")\n                return False, {}\n\n        except Exception as e:\n            logger.exception(f\"Unexpected error sending transaction: {e}\")\n            return False, {}\n</code></pre>"},{"location":"core/#iwa.core.chain.ChainInterface.wait_for_no_pending_tx","title":"<code>wait_for_no_pending_tx(from_address, max_wait_seconds=60, poll_interval=2.0)</code>","text":"<p>Wait for no pending transactions for a specified time.</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def wait_for_no_pending_tx(\n    self, from_address: str, max_wait_seconds: int = 60, poll_interval: float = 2.0\n):\n    \"\"\"Wait for no pending transactions for a specified time.\"\"\"\n    start_time = time.time()\n    while time.time() - start_time &lt; max_wait_seconds:\n        latest_nonce = self.web3.eth.get_transaction_count(\n            from_address, block_identifier=\"latest\"\n        )\n        pending_nonce = self.web3.eth.get_transaction_count(\n            from_address, block_identifier=\"pending\"\n        )\n\n        if pending_nonce == latest_nonce:\n            return True\n\n        time.sleep(poll_interval)\n\n    return False\n</code></pre>"},{"location":"core/#iwa.core.chain.SupportedChain","title":"<code>SupportedChain</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>SupportedChain</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>class SupportedChain(BaseModel):\n    \"\"\"SupportedChain\"\"\"\n\n    name: str\n    rpcs: List[str]\n    chain_id: int\n    native_currency: str\n    tokens: Dict[str, EthereumAddress] = {}\n\n    @property\n    def rpc(self) -&gt; str:\n        \"\"\"Get the first RPC (primary).\"\"\"\n        return self.rpcs[0] if self.rpcs else \"\"\n\n    def get_token_address(self, token_address_or_name: str) -&gt; Optional[EthereumAddress]:\n        \"\"\"Get token address\"\"\"\n        try:\n            address = EthereumAddress(token_address_or_name)\n        except Exception:\n            address = None\n\n        # If a valid address is provided and it exists in the supported tokens, return it\n        if address and address in self.tokens.values():\n            return address\n\n        # If a token name is provided, return the corresponding address\n        if address is None:\n            return self.tokens.get(token_address_or_name, None)\n\n        return None\n</code></pre>"},{"location":"core/#iwa.core.chain.SupportedChain.rpc","title":"<code>rpc</code>  <code>property</code>","text":"<p>Get the first RPC (primary).</p>"},{"location":"core/#iwa.core.chain.SupportedChain.get_token_address","title":"<code>get_token_address(token_address_or_name)</code>","text":"<p>Get token address</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>def get_token_address(self, token_address_or_name: str) -&gt; Optional[EthereumAddress]:\n    \"\"\"Get token address\"\"\"\n    try:\n        address = EthereumAddress(token_address_or_name)\n    except Exception:\n        address = None\n\n    # If a valid address is provided and it exists in the supported tokens, return it\n    if address and address in self.tokens.values():\n        return address\n\n    # If a token name is provided, return the corresponding address\n    if address is None:\n        return self.tokens.get(token_address_or_name, None)\n\n    return None\n</code></pre>"},{"location":"core/#iwa.core.chain.Gnosis","title":"<code>Gnosis</code>","text":"<p>               Bases: <code>SupportedChain</code></p> <p>Gnosis Chain</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>@singleton\nclass Gnosis(SupportedChain):\n    \"\"\"Gnosis Chain\"\"\"\n\n    name: str = \"Gnosis\"\n    rpcs: List[str] = (\n        Secrets().gnosis_rpc.get_secret_value().split(\",\")\n        if Secrets().gnosis_rpc\n        else []\n    )\n    chain_id: int = 100\n    native_currency: str = \"xDAI\"\n    tokens: Dict[str, EthereumAddress] = {\n        \"OLAS\": EthereumAddress(\"0xcE11e14225575945b8E6Dc0D4F2dD4C570f79d9f\"),\n        \"WXDAI\": EthereumAddress(\"0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d\"),\n        \"USDC\": EthereumAddress(\"0x2a22f9c3b484c3629090FeED35F17Ff8F88f76F0\"),\n        \"SDAI\": EthereumAddress(\"0xaf204776c7245bF4147c2612BF6e5972Ee483701\"),\n        \"EURE\": EthereumAddress(\"0x420CA0f9B9b604cE0fd9C18EF134C705e5Fa3430\"),\n    }\n</code></pre>"},{"location":"core/#iwa.core.chain.Ethereum","title":"<code>Ethereum</code>","text":"<p>               Bases: <code>SupportedChain</code></p> <p>Ethereum Mainnet</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>@singleton\nclass Ethereum(SupportedChain):\n    \"\"\"Ethereum Mainnet\"\"\"\n\n    name: str = \"Ethereum\"\n    rpcs: List[str] = (\n        Secrets().ethereum_rpc.get_secret_value().split(\",\")\n        if Secrets().ethereum_rpc\n        else []\n    )\n    chain_id: int = 1\n    native_currency: str = \"ETH\"\n</code></pre>"},{"location":"core/#iwa.core.chain.Base","title":"<code>Base</code>","text":"<p>               Bases: <code>SupportedChain</code></p> <p>Base</p> Source code in <code>src/iwa/core/chain.py</code> <pre><code>@singleton\nclass Base(SupportedChain):\n    \"\"\"Base\"\"\"\n\n    name: str = \"Base\"\n    rpcs: List[str] = (\n        Secrets().base_rpc.get_secret_value().split(\",\")\n        if Secrets().base_rpc\n        else []\n    )\n    chain_id: int = 8453\n    native_currency: str = \"ETH\"\n</code></pre>"},{"location":"plugins/","title":"Plugins","text":"<p>This section documents the available plugins in the Iwa framework.</p>"},{"location":"plugins/#gnosis","title":"Gnosis","text":""},{"location":"plugins/#iwa.plugins.gnosis.plugin","title":"<code>iwa.plugins.gnosis.plugin</code>","text":""},{"location":"plugins/#iwa.plugins.gnosis.plugin.GnosisPlugin","title":"<code>GnosisPlugin</code>","text":"<p>               Bases: <code>Plugin</code></p> Source code in <code>src/iwa/plugins/gnosis/plugin.py</code> <pre><code>class GnosisPlugin(Plugin):\n    @property\n    def name(self) -&gt; str:\n        return \"gnosis\"\n\n    def get_cli_commands(self) -&gt; Dict[str, callable]:\n        return {\n            \"create-safe\": self.create_safe_command\n        }\n\n    def create_safe_command(\n        self,\n        tag: Optional[str] = typer.Option(\n            None,\n            \"--tag\",\n            \"-t\",\n            help=\"Tag for this account\",\n        ),\n        owners: str = typer.Option(\n            ...,\n            \"--owners\",\n            \"-o\",\n            help=\"Comma-separated list of owner addresses or tags.\",\n        ),\n        threshold: int = typer.Option(\n            ...,\n            \"--threshold\",\n            \"-h\",\n            help=\"Number of required confirmations.\",\n        ),\n        chain_name: str = typer.Option(\n            \"gnosis\",\n            \"--chain\",\n            \"-c\",\n            help=\"Chain to deploy the multisig on.\",\n        ),\n    ):\n        \"\"\"Create a new multisig account (Safe)\"\"\"\n        key_storage = KeyStorage()\n        owner_list = [owner.strip() for owner in owners.split(\",\")]\n        try:\n            key_storage.create_safe(\n                deployer_tag_or_address=\"master\",\n                owner_tags_or_addresses=owner_list,\n                threshold=threshold,\n                chain_name=chain_name,\n                tag=tag,\n            )\n        except ValueError as e:\n            typer.echo(f\"Error: {e}\")\n            raise typer.Exit(code=1) from e\n</code></pre>"},{"location":"plugins/#iwa.plugins.gnosis.plugin.GnosisPlugin.create_safe_command","title":"<code>create_safe_command(tag=typer.Option(None, '--tag', '-t', help='Tag for this account'), owners=typer.Option(..., '--owners', '-o', help='Comma-separated list of owner addresses or tags.'), threshold=typer.Option(..., '--threshold', '-h', help='Number of required confirmations.'), chain_name=typer.Option('gnosis', '--chain', '-c', help='Chain to deploy the multisig on.'))</code>","text":"<p>Create a new multisig account (Safe)</p> Source code in <code>src/iwa/plugins/gnosis/plugin.py</code> <pre><code>def create_safe_command(\n    self,\n    tag: Optional[str] = typer.Option(\n        None,\n        \"--tag\",\n        \"-t\",\n        help=\"Tag for this account\",\n    ),\n    owners: str = typer.Option(\n        ...,\n        \"--owners\",\n        \"-o\",\n        help=\"Comma-separated list of owner addresses or tags.\",\n    ),\n    threshold: int = typer.Option(\n        ...,\n        \"--threshold\",\n        \"-h\",\n        help=\"Number of required confirmations.\",\n    ),\n    chain_name: str = typer.Option(\n        \"gnosis\",\n        \"--chain\",\n        \"-c\",\n        help=\"Chain to deploy the multisig on.\",\n    ),\n):\n    \"\"\"Create a new multisig account (Safe)\"\"\"\n    key_storage = KeyStorage()\n    owner_list = [owner.strip() for owner in owners.split(\",\")]\n    try:\n        key_storage.create_safe(\n            deployer_tag_or_address=\"master\",\n            owner_tags_or_addresses=owner_list,\n            threshold=threshold,\n            chain_name=chain_name,\n            tag=tag,\n        )\n    except ValueError as e:\n        typer.echo(f\"Error: {e}\")\n        raise typer.Exit(code=1) from e\n</code></pre>"},{"location":"plugins/#olas","title":"Olas","text":""},{"location":"plugins/#iwa.plugins.olas.plugin","title":"<code>iwa.plugins.olas.plugin</code>","text":""},{"location":"plugins/#iwa.plugins.olas.plugin.OlasPlugin","title":"<code>OlasPlugin</code>","text":"<p>               Bases: <code>Plugin</code></p> Source code in <code>src/iwa/plugins/olas/plugin.py</code> <pre><code>class OlasPlugin(Plugin):\n    @property\n    def name(self) -&gt; str:\n        return \"olas\"\n\n    @property\n    def config_model(self) -&gt; Type[BaseModel]:\n        return OlasConfig\n\n    def get_cli_commands(self) -&gt; Dict[str, callable]:\n        return {\n            \"create\": self.create_service,\n        }\n\n    def create_service(\n        self,\n        chain_name: str = typer.Option(\"gnosis\", \"--chain\", \"-c\"),\n        owner: Optional[str] = typer.Option(None, \"--owner\", \"-o\"),\n        token: Optional[str] = typer.Option(None, \"--token\"),\n        bond: int = typer.Option(1, \"--bond\", \"-b\"),\n    ):\n        \"\"\"Create a new Olas service\"\"\"\n        wallet = Wallet()\n        manager = ServiceManager(wallet)\n        # Note: Manager logic currently depends on internal config state which might need setup\n        manager.create(chain_name, owner, token, bond)\n</code></pre>"},{"location":"plugins/#iwa.plugins.olas.plugin.OlasPlugin.create_service","title":"<code>create_service(chain_name=typer.Option('gnosis', '--chain', '-c'), owner=typer.Option(None, '--owner', '-o'), token=typer.Option(None, '--token'), bond=typer.Option(1, '--bond', '-b'))</code>","text":"<p>Create a new Olas service</p> Source code in <code>src/iwa/plugins/olas/plugin.py</code> <pre><code>def create_service(\n    self,\n    chain_name: str = typer.Option(\"gnosis\", \"--chain\", \"-c\"),\n    owner: Optional[str] = typer.Option(None, \"--owner\", \"-o\"),\n    token: Optional[str] = typer.Option(None, \"--token\"),\n    bond: int = typer.Option(1, \"--bond\", \"-b\"),\n):\n    \"\"\"Create a new Olas service\"\"\"\n    wallet = Wallet()\n    manager = ServiceManager(wallet)\n    # Note: Manager logic currently depends on internal config state which might need setup\n    manager.create(chain_name, owner, token, bond)\n</code></pre>"},{"location":"plugins/#telegram","title":"Telegram","text":""},{"location":"plugins/#iwa.plugins.telegram.plugin","title":"<code>iwa.plugins.telegram.plugin</code>","text":""},{"location":"plugins/#iwa.plugins.telegram.plugin.TelegramPlugin","title":"<code>TelegramPlugin</code>","text":"<p>               Bases: <code>Plugin</code></p> Source code in <code>src/iwa/plugins/telegram/plugin.py</code> <pre><code>class TelegramPlugin(Plugin):\n    @property\n    def name(self) -&gt; str:\n        return \"telegram\"\n\n    def get_cli_commands(self) -&gt; Dict[str, callable]:\n        return {\n            \"start-bot\": self.start_bot_command\n        }\n\n    def start_bot_command(self):\n        \"\"\"Start the Telegram bot.\"\"\"\n        secrets = Secrets()\n        if not secrets.telegram_bot_token:\n             typer.echo(\"Error: telegram_bot_token not set in secrets.\")\n             raise typer.Exit(code=1)\n\n        token = secrets.telegram_bot_token.get_secret_value()\n\n        application = ApplicationBuilder().token(token).build()\n\n        start_handler = CommandHandler('start', self.start)\n        balance_handler = CommandHandler('balance', self.balance)\n\n        application.add_handler(start_handler)\n        application.add_handler(balance_handler)\n\n        logger.info(\"Starting Telegram bot...\")\n        application.run_polling()\n\n    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        secrets = Secrets()\n        if update.effective_chat.id != secrets.telegram_chat_id:\n            await context.bot.send_message(\n                chat_id=update.effective_chat.id,\n                text=\"Unauthorized access.\"\n            )\n            return\n\n        await context.bot.send_message(\n            chat_id=update.effective_chat.id,\n            text=\"I'm the IWA bot. I can help you manage your wallet securely.\"\n        )\n\n    async def balance(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        secrets = Secrets()\n        if update.effective_chat.id != secrets.telegram_chat_id:\n             return\n\n        wallet = Wallet()\n        master = wallet.master_account\n\n        if not master:\n            await context.bot.send_message(\n                chat_id=update.effective_chat.id,\n                text=\"No master account found.\"\n            )\n            return\n\n        balance_eth = wallet.get_native_balance_eth(master.address, chain_name=\"gnosis\")\n        text = f\"Master Account Balance (Gnosis): {balance_eth:.4f} xDAI\" if balance_eth is not None else \"Failed to fetch balance.\"\n\n        await context.bot.send_message(\n            chat_id=update.effective_chat.id,\n            text=text\n        )\n</code></pre>"},{"location":"plugins/#iwa.plugins.telegram.plugin.TelegramPlugin.start_bot_command","title":"<code>start_bot_command()</code>","text":"<p>Start the Telegram bot.</p> Source code in <code>src/iwa/plugins/telegram/plugin.py</code> <pre><code>def start_bot_command(self):\n    \"\"\"Start the Telegram bot.\"\"\"\n    secrets = Secrets()\n    if not secrets.telegram_bot_token:\n         typer.echo(\"Error: telegram_bot_token not set in secrets.\")\n         raise typer.Exit(code=1)\n\n    token = secrets.telegram_bot_token.get_secret_value()\n\n    application = ApplicationBuilder().token(token).build()\n\n    start_handler = CommandHandler('start', self.start)\n    balance_handler = CommandHandler('balance', self.balance)\n\n    application.add_handler(start_handler)\n    application.add_handler(balance_handler)\n\n    logger.info(\"Starting Telegram bot...\")\n    application.run_polling()\n</code></pre>"}]}